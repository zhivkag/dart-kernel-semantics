\documentclass{article}

% Macros used below have been contributed in part by Olivier Danvy and Kevin Millikin
\input{danvy-millikin-LMCS.mac}
\usepackage{amsmath} 

\begin{document}
\title{Dart Kernel Semantics \\ (draft)}

\maketitle

The small-step operational semantics of Dart Kernel is given by an abstract machine in the style of the CESK machine. The machine is defined by a single step transition function where each step of the machine starts in a configuration and deterministically gives a next configuration.

\section{Definitions}
\label{sec:definitions}
\subsection{Conventions}
\label{subsec:conventions}
\begin{itemize}
\setlength{\itemsep}{0pt}
\item Symbols ":" and $\in$ are used interchangeably.
\item Names of variables are italicized.
\item Names of variables of syntactic domains start with an upper case letter.
\item Names of domains are written in bold (e.g. $\dexpr$).
\item Names of configuration and continuation kinds are written in normal text (e.g. VarSetK).
\item Names of meta-functions start with lower case letter (e.g. extend).
\item Symbol ":=" is read as "denotes".
\item "$\mlist{\mathbf{X}}$" := domain of meta-lists of elements from domain "$\mathbf{X}$". Note that the word "List" here is not in bold, so that it isn't confused with the domain $\mathbf{List}$ of Dart objects.
\end{itemize}
\subsection{Domains}
\label{subsec:domains}
\[
  \begin{array}{lcll}
	\expr, \expri{i} & : & \dexpr & \textrm{syntactic domain of expressions}\\
	\exprs & : & \mlist{\dexpr}\\[2mm]

	\stmt, \stmti{i} & : & \dstmt & \textrm{syntactic domain of statements}\\
	\stmts & : & \mlist{\dstmt}  & \textrm{}\\[2mm]

	\econt & : & \decont & \textrm{domain of expression continuations}\\
	\acont & : & \dacont & \textrm{domain of application continuations}\\
	\scont & : & \dscont & \textrm{domain of statement continuations}\\
	\bcont & : & \dbcont & \textrm{domain of break continuations}\\
	\switchcont & : & \dswitchcont & \textrm{domain of switch continuations}\\[2mm]

	\lbl & : & \dlbl & \textrm{domain of labels}\\
	\lbl & : & \mlist{\dlbl} \\
	\clbl & : & \dclbl & \textrm{domain of switch labels}\\
	\clbl & : & \mlist{\dclbl} \\[2mm]

	\handler & : & \dhandler & \textrm{syntactic domain of exception handlers} \\
	\strace & : & \mlist{\dexpr} & \textrm{domain of stack traces}\\
	\cex & : &  \emptyset + \dval & \textrm{domain of current expetion values}\\
	\cstrace & : & \emptyset + \mlist{\dexpr} & \textrm{domain of current exception stack traces}\\[2mm]

	\varmeta & : & \dvardecl & \textrm{domain of variable declarations}\\
	\loc & : & \dlocation & \textrm{domain of store locations}\\
	\val & : & \dval & \textrm{domain of values}\\
	\vals & : & \mlist{\dval}\\
	\env & : & \denv & \textrm{domain of environments}

  \end{array}
\]
\subsection{Meta-functions}
\label{subsec:meta-functions}
\subsubsection{Dereferencing}
\label{subsubsection:dereferecing}
Function "!" is used to "dereference" items stored in environments. It has an implicit argument which is the store of CESK machine.

\begin{align*}
  \deref : \dlocation &\rightarrow \dval \\
  \deref\loc &=  \val, \textrm{ with $\val$ the value in store at location } \loc
\end{align*}

\subsubsection{String Concatenation}
\label{subsubsec:string-concatenation}
Function $stringValue$ concatenates strings from the given meta-list.

\[stringValue : \mlist{\dstring} \rightarrow \dstring\]

\subsubsection{Updating Environment}
\label{subsubsec:updating-env}

\[extend : \denv \times \dfunval \times \mlist{\dval} \rightarrow  \denv \]

\subsection{Notations}
\label{subsec:notations}

\[
  \begin{array}{lcl}
    [] &:=& \textrm{empty list}\\
    X :: list &:=& \textrm{a meta-list that is constructed by adding element X to the head}\\
    && \textrm{of the meta-list list}
  \end{array}
\]
\subsection{Configurations for the CESK machine}
\label{subsec:cesk-configs}
The state space of the CESK machine contains various kinds of configurations, each containing components for applying the appropriate continuation in order to transition to the next configuration. 

\[
  \begin{array}{lcl}
	\evalconf{\expr}{\env}{st}{cex}{cst}{\econt} & : &
	\textrm{EvalConfiguration}\\

	\evallistconf{\exprs}{\env}{st}{cex}{cst}{\econt} & : &
	\textrm{EvalListConfiguration}\\

	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}  & : &
	\textrm{ExecConfiguration}\\[3mm]

	\contconf{\econt}{\val} & : &
	\textrm{ValuePassingConfiguration}\\

	\acontconf{\acont}{\vals} & : &
	\textrm{ApplicationConfiguration}\\

	\acontconf{\scont}{\env} & : &
	\textrm{ForwardConfiguration}\\[3mm]

	\throwconf{\handler}{\val}{\strace} & : &
	\textrm{ThrowConfiguration}\\

	\breakconf{\bcont} & : &
	\textrm{BreakConfiguration}\\

	\switchconf{\switchcont} & : &
	\textrm{SwitchConfiguration}\\

  \end{array}
\]
\subsection{Environment}
\label{subsec:env-definition}
The environment is a function that maps a variable to a location in the store.
\[\env \in \denv = \dvardecl \rightarrow \dlocation\] 
\subsection{Store}
\label{subsec:store-definition}
The store, $s$, maps a location, $\loc$, to a value, $\val$. The store is mutable and should not be confused with a function. It is possible to change the transition rules, so that the store is immutable, and right hand side configurations receive an updated copy of it. However, for the sake of simplicity, a global mutable store is assumed. 
\[s : \dlocation \rightarrow \dval \]
Therefore a variable look-up will consist of looking up the address of a variable from the environment with $\loc = \env(\varmeta)$ and reading the stored value $v$ with $\deref\loc$. For definition of "$\deref$" see Section~\ref{subsubsection:dereferecing} 

\subsection{Continuations}
\label{subsec:continuations-definition}

Continuation is the function that represents the rest of the program and is has the information needed to resume the execution of the program. 
There are various types of continuations depending on the next statement to be executed or next expression to be evaluated.

\subsection{Values}
\label{subsec:values}
\subsection{Literal values}
\label{subsubsec:literal-values}
\[
  \begin{array}{lcl}
	\val \in \dlitval &=& \mathbf{int} + \mathbf{bool} + \mathbf{double}\\
	&& + \mathbf{List} + \mathbf{Map} + \mathbf{String} + \mathbf{Symbol} + \mathbf{Type}
  \end{array}
\]
\subsection{Object values}
\label{subsec:object-values}
\[
  \begin{array}{lcl}
	\dobjval &:& \dclass \times \mlist{\dlocation}\\
	\dclass &:& superclass \times interfaces \times fields \times getters \times setters \times methods
  \end{array}
\]
\subsection{Function values}
\label{subsec:function-values}
\[
	\dfunval : \dformals \times \dstmt \times \denv
\]

\section{Semantics}
\label{sec:semantics}
\subsection{Expression evaluation}
\label{subsec:expr-evaluation}
\subsubsection{Basic literal evaluation}
\label{subsubsec:basic-literal-eval}
Kernel literals are evaluated to a value $\val \in \dlitval$. Transitions of the CESK machine for basic literals are presented below:
\[
  \begin{array}{lcll}
	\evalconf{\mathrm{BasicLiteral(\synval)}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\mathrm{LiteralValue(\synval)}}\\[2mm]

	\evalconf{\mathrm{IntLiteral(\synval)}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\mathrm{IntValue(\synval)}}\\[2mm]

	\evalconf{\mathrm{DoubleLiteral(\synval)}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\mathrm{DoubleValue(\synval)}}\\[2mm]

	\evalconf{\mathrm{BoolLiteral(\synval)}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\mathrm{BoolValue(\synval)}}\\[2mm]

	\evalconf{\mathrm{StringLiteral(\synval)}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\mathrm{StringValue(\synval)}}

  \end{array}
\]
with:
\[
  \begin{array}{lcllcl}
	\textrm{IntLiteral} &\in &\mathbf{int},  &\textrm{DoubleLiteral} &\in &\mathbf{double}\\
	\textrm{BoolLiteral} &\in &\mathbf{bool}, &\textrm{StringLiteral} &\in &\mathbf{String}
  \end{array}
\]

\subsubsection{Variable assignment and lookup}
\label{subsubsec:variable-assignment-and-lookup}
A variable $\varmeta$ are accessed by reading the value stored at location $\env(\varmeta)$ in the store $s$. Assigning a value to a variable will modify the store and the value stored at location  $\env(\varmeta)$.

\[
  \begin{array}{lcl}
	\evalconf{\varmeta}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\deref\env(\varmeta)}\\[2mm]

	\evalconf{\varmeta = \expr}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\varsetk{\env}{\varmeta}{\econt}}\\[2mm]

	\contconf{\varsetk{\env}{\varmeta}{\econt}}{\val}
	& \Rightarrow &
	\contconf{\econt}{\val}, \hspace{5mm} \deref\env(\varmeta) = \val \textrm{ after transition}

  \end{array}
\]

\subsubsection{Boolean expresions}
% exact notation TBD
\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}

\[
  \begin{array}{lll}
	\evalconf{\neg\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\notk{\econt}}\\[2mm]

	\contconf{\notk{\econt}}{\true}
	& \Rightarrow &
	\contconf{\econt}{\false}\\[2mm]

	\contconf{\notk{\econt}}{\false}
	& \Rightarrow &
	\contconf{\econt}{\true}
  \end{array}
\]

\noindent
Let $\econt' = \andk{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}$ below:

\[
  \begin{array}{lcl}
	\evalconf{\expri{1} \land \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\andk{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\true}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

	\contconf{\andk{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\false}
	& \Rightarrow &
	\contconf{\econt}{\false}\\
  \end{array}
\]

\noindent
Let $\econt' = \ork{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}$ below:

\[
  \begin{array}{lcl}
	\evalconf{\expri{1} \lor \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\ork{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\false}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

	\contconf{\ork{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\true}
	& \Rightarrow &
	\contconf{\econt}{\true}\\
  \end{array}
\]
\noindent
Let $\econt' = \conditionalk{\expri{1}}{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}$ below:
\[
  \begin{array}{lcl}
	\evalconf{\expr \textbf{ ? } \expri{1} \textbf{ : } \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\econt'}{\true}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

	\contconf{\econt'}{\false}
	& \Rightarrow &
	\evalconf{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]
  \end{array}
\]

\subsubsection{Let}
Let $\econt' = \letk{\expri{2}}{\env}{\varmeta}{\strace}{\cstrace}{\cex}{\econt}$ below:
\[
  \begin{array}{lcl}
	\evalconf{\textbf{let } \varmeta = \expri{1} \textbf{ in } \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]
	
	%\contconf{\econt'}{\val}
	%& \Rightarrow &
	%\evalconf{\expri{2}}{\env\lbrace\rbrace}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

  \end{array}
\]
\subsubsection{Static Invocation}
\subsubsection{Evaluation of list of expressions}
\subsection{Statement execution}
\label{subsec:stmt-exectution}
\subsubsection{Variable Declaration}

\end{document}
