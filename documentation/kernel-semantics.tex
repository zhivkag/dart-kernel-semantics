\documentclass{article}

\usepackage[fleqn]{amsmath}
%
\usepackage{a4wide}
%
\usepackage{url,cite,amssymb,stmaryrd,alltt,xypic,appendix}
%
\usepackage{color,alltt}
%
\definecolor{shade}{gray}{0.75}
%
\usepackage{hyperref}
\usepackage{chngcntr}
\usepackage{ifthen}
\usepackage[fleqn]{mathtools}
%
\newcommand{\shadethis}[1]{\colorbox{shade}
{\protect\rule[-0.95mm]{0mm}{3.95mm}\hspace{0.3mm}#1\hspace{0.3mm}}}
%
% Macros used below have been contributed in part by Olivier Danvy and Kevin Millikin
\input{danvy-millikin-LMCS.mac}

\renewcommand{\emptyset}{\varnothing}
\DeclareMathOperator{\extend}{extend}
\DeclareMathOperator{\concat}{concat}

%%
% Commands to typeset transitions of CESK machine.
%
% \cesktrans{FROM}{TO}
% \cesktransalign{FROM}{TO}
% \cesktranssplit{FROM}{TO}
%
% Typesets a transition from configuration FROM to configuration TO. Like this:
%
%     FROM => TO
%
% "Align" variant has an embedded "&" inside, immediately before the transition
% sign "=>".  It means that the command should be put into an environment that
% aligns its multi-line content using "&" signs, for example "align".
%
% "Split" variant has an embedded "\\" inside, immediately after the transition
% sign "=>".  It is useful for putting long equations in an environment such as
% "split".
%%
\newcommand{\cesktrans}[2]{\ensuremath{{#1} \Rightarrow {#2}}}
\newcommand{\cesktransalign}[2]{\ensuremath{{#1} &\Rightarrow {#2}}}
\newcommand{\cesktranssplit}[2]{\ensuremath{{#1} \Rightarrow\\ {#2}}}


%%
% Commands to typeset transitions of CESK machine with clarifying clause.
%
% \cesktranswhere{FROM}{TO}{WHERE}
% \cesktranswherealign{FROM}{TO}{WHERE}
% \cesktranswherealign*{FROM}{TO}{WHERE}
% \cesktranswheresplit{FROM}{TO}{WHERE}
% \cesktranswheresplit*{FROM}{TO}{WHERE}
%
% Typesets a transition from configuration FROM to configuration TO.  These
% commands have a clarifying clause that explains the meaning of some new
% symbols introduced by the transition.
%
% The "align" versions have an embedded "&" inside, immideately before the
% transition sign "=>".  It means that the command sould be put into an
% environment that aligns its multi-line content using "&" signs, for example
% "align".  The non-starred "align" variant puts the additional clause to the
% same line as the transition itself, separating it with a comma.  The starred
% version puts the additional clause on the next line.
%
% Here is how non-starred version looks like:
%
%     FROM => TO, WHERE
%
% Here is how starred version looks like:
%
%     FROM => TO,
%          WHERE
%
% "Split" variants has embedded "\\" inside.  Non-starred "split" variant have one
% after the comma.  Starred "split" variant have one additional "\\" after
% the transition sign "=>".  It is useful for putting long equations in an
% environment such as "split", "gather", or "multline".  Note that if an
% environment generates a new equation number for each line, it can be disabled
% by putting "\notag" inside the arguments where the number is undesirable.
%%
\newcommand{\cesktranswhere}[3]{\ensuremath{{#1} \Rightarrow {#2}, {#3}}}
\newcommand{\cesktranswherealignNoStar}[3]{\ensuremath{{#1} &\Rightarrow {#2}, {#3}}}
\newcommand{\cesktranswherealignStar}[3]{\ensuremath{{#1} &\Rightarrow \begin{aligned}[t]&{#2},\\&{#3}\end{aligned}}}
\makeatletter
\newcommand{\cesktranswherealign}{%
    \@ifstar
        \cesktranswherealignStar%
        \cesktranswherealignNoStar%
}
\makeatother
\newcommand{\cesktranswheresplitNoStar}[3]{\ensuremath{{#1} \Rightarrow {#2},\\{#3}}}
\newcommand{\cesktranswheresplitStar}[3]{\ensuremath{{#1} \Rightarrow\\ {#2},\\{#3}}}
\makeatletter
\newcommand{\cesktranswheresplit}{%
    \@ifstar
        \cesktranswheresplitStar%
        \cesktranswheresplitNoStar%
}
\makeatother


\begin{document}
\title{Dart Kernel Semantics \\ (draft)}

\maketitle

The small-step operational semantics of Dart Kernel is given by an abstract machine in the style of the CESK machine.
The machine is defined by a single step transition function where each step of the machine starts in a configuration and deterministically gives the next configuration.

\section{Definitions}
\label{sec:definitions}
\subsection{Conventions}
\label{subsec:conventions}
\begin{itemize}
\setlength{\itemsep}{0pt}
\item Symbols ``:'' and ``$\in$'' are used interchangeably.
\item Names of variables are italicized.
\item Names of variables of syntactic domains start with an upper case letter.
\item Names of domains are written in bold (e.g. ``$\mathbf{X}$'').
\item Names of continuation kinds are written in normal text (e.g. VarSetK).
\item Names of meta-functions start with lower case letter (e.g. $\extend$).
\item ``$\mlist{\mathbf{X}}$'' denotes the domain of meta-lists of elements from domain ``$\mathbf{X}$''.
Note that the word ``List'' here is not in bold, so that it isn't confused with the domain $\mathbf{List}$ of Dart objects.
\end{itemize}
\subsection{Domains}
\label{subsec:domains}
% Variables
\newcommand{\expr}{\ensuremath{\mathit{E}}}
\newcommand{\expri}[1]{\expr_\ensuremath{\mathit{#1}}}
\newcommand{\exprs}{\expr\ensuremath{\mathit{s}}}

\newcommand{\stmt}{\ensuremath{\mathit{S}}}
\newcommand{\stmti}[1]{\stmt_\ensuremath{#1}}
\newcommand{\stmts}{\stmt\ensuremath{\mathit{s}}}

\newcommand{\handler}{\ensuremath{\mathit{H}}}
\newcommand{\strace}{\ensuremath{st}}
\newcommand{\cstrace}{\ensuremath{c}\strace}
\newcommand{\cex}{\ensuremath{cex}}

\newcommand{\scase}{\mathit{SC}}
\newcommand{\scases}{\scase\ensuremath{\mathit{s}}}
\newcommand{\ccase}{\mathit{CC}}
\newcommand{\ccases}{\scase\ensuremath{\mathit{s}}}

\newcommand{\vals}{\ensuremath{vs}}
\newcommand{\env}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\alpha}}

\newcommand{\lbl}{\ensuremath{lbl}}
\newcommand{\lbls}{\ensuremath{lbls}}
\newcommand{\clbl}{\ensuremath{clbl}}
\newcommand{\clbls}{\ensuremath{clbls}}

\newcommand{\econt}{\cont_\ensuremath{E}}
\newcommand{\acont}{\cont_\ensuremath{A}}
\newcommand{\scont}{\cont_\ensuremath{S}}
\newcommand{\bcont}{\cont_\ensuremath{B}}
\newcommand{\switchcont}{\cont_{\ensuremath{switch}}}

\newcommand{\funval}[3]{\mathrm{FunctionValue}({#1},\,{#2},\,{#3})}
\newcommand{\objval}{\mathrm{ObjectValue}(class, fields)}

\newcommand{\formal}{\ensuremath{A}}
\newcommand{\formali}[1]{\ensuremath{A_{#1}}}
\newcommand{\formals}{\ensuremath{As}}

% Domains
\newcommand{\dexpr}{\mathbf{Expr}}
\newcommand{\dstmt}{\mathbf{Stmt}}
\newcommand{\dhandler}{\mathbf{Handler}}

\newcommand{\decont}{\mathbf{ExprCont}}
\newcommand{\dscont}{\mathbf{StmtCont}}
\newcommand{\dacont}{\mathbf{ApplCont}}
\newcommand{\dbcont}{\mathbf{BreakCont}}
\newcommand{\dswitchcont}{\mathbf{SwitchCont}}

\newcommand{\dlbl}{\mathbf{Label}}
\newcommand{\dclbl}{\mathbf{SwitchLabel}}

\newcommand{\denv}{\mathbf{Env}}
\newcommand{\dlocation}{\mathbf{Location}}

\newcommand{\dval}{\mathbf{Value}}
\newcommand{\dvardecl}{\mathbf{VariableDeclaration}}
\newcommand{\dstring}{\mathbf{StringValue}}
\newcommand{\dfunval}{\mathbf{FunctionValue}}
\newcommand{\dlitval}{\mathbf{LiteralValue}}
\newcommand{\dobjval}{\mathbf{ObjectValue}}

\newcommand{\dclass}{\mathbf{Class}}
\newcommand{\dformals}{\mathbf{Formals}}
\[
  \begin{array}{ccll}
	\expr, \expri{i}
	& : & \dexpr & \textrm{syntactic domain of expressions}\\
	\exprs
	& : & \mlist{\dexpr}\\[2mm]

	\stmt, \stmti{i}
	& : & \dstmt & \textrm{syntactic domain of statements}\\
	\stmts
	& : & \mlist{\dstmt}  & \textrm{}\\[2mm]

	\econt
	& : & \decont & \textrm{domain of expression continuations}\\
	\acont
	& : & \dacont & \textrm{domain of application continuations}\\
	\scont
	& : & \dscont & \textrm{domain of statement continuations}\\
	\bcont
	& : & \dbcont & \textrm{domain of break continuations}\\
	\switchcont
	& : & \dswitchcont & \textrm{domain of switch continuations}\\[2mm]

	\lbl & : & \dlbl & \textrm{domain of labels}\\
	\lbls & : & \mlist{\dlbl} \\
	\clbl & : & \dclbl & \textrm{domain of switch labels}\\
	\clbls & : & \mlist{\dclbl} \\[2mm]

	\handler
	& : & \dhandler & \textrm{syntactic domain of exception handlers} \\
	\strace
	& : & \mlist{\dexpr} & \textrm{domain of stack traces}\\
	\cex
	& : &  \emptyset + \dval & \textrm{domain of current expetion values}\\
	\cstrace
	& : & \emptyset + \mlist{\dexpr} & \textrm{domain of current exception stack traces}\\[2mm]

	\varmeta
	& : & \dvardecl & \textrm{domain of variable declarations}\\
	\loc
	& : & \dlocation & \textrm{domain of store locations}\\
	\val
	& : & \dval & \textrm{domain of values}\\
	\vals
	& : & \mlist{\dval}\\
	\env
	& : & \denv & \textrm{domain of environments}\\[2mm]
  \end{array}
\]

\[
  \begin{array}{ccll}
	\formal, \formali{i} & : & \dvardecl\\
	\formals & : & \dformals = \mlist{\dvardecl} &\textrm{ domain of formals}\\

  \end{array}
\]

\subsection{Notations}
\label{subsec:notations}

\[
  \begin{array}{lcl}
    [] &\text{---}& \text{empty list}\\
    X :: list &\text{---}& \text{a meta-list that is constructed by adding element $X$ to the head}\\
    && \text{of the meta-list $list$}
  \end{array}
\]

\subsection{Store}
\label{subsec:store-definition}
The store, $s$, maps a location, $\loc$, to a value, $\val$.
The store is a mutable map and should not be confused with a function.
A global store is assumed and locations reachable from a given scope are defined by the current environment function.
\[s : \dlocation \rightarrow \dval \]
\subsubsection{Dereferencing}
\label{subsubsection:dereferecing}
\newcommand{\deref}[1]{!#1}
Function ``$\deref{}$'' is used to access a value stored in the store provided the corresponding location.
The location is stored in the environment, or in the list of field locations for object values.
``$\deref{}$'' has an implicit argument which is the store of CESK machine.

\begin{align*}
  \deref{} \in \dlocation &\rightarrow \dval \\
  \deref{\loc} &=  \val, \textrm{ with $\val$ the value in store at location } \loc
\end{align*}
\subsubsection{Update}
\label{subsubsec:store-update}
\newcommand{\update}[2]{{#1} := {#2}}
Function ``$\update{\loc}{\val}$'' updates the store at location $\loc \in \dlocation$ with value $\val \in \dval$.
It has an implicit argument which is the store of the CESK machine.
\begin{align*}
  \update{}{} \in \dlocation \times \dval &\rightarrow  \dval\\
  \update{\loc}{\val} &= \val, \textrm{ with $\val$ the value in store at location $\loc$}
\end{align*}
\subsection{Environment}
\label{subsec:env-definition}
The environment is a function that maps a variable to a location in the store.
\[\env \in \denv = \dvardecl \rightarrow \dlocation\]
When an environment is needed to further execute the program, it is saved by the caller in the corresponding continuation.

\subsubsection{Extend}
\label{subsubsec:extend-env}

Function ``$\extend$'' creates a new environment by extending the provided environment with new bindings for the variable declarations to fresh locations for each of the provided values.
\begin{align*}
  \extend \in \denv \times \mlist{\dvardecl} \times \mlist{\dval} &\rightarrow  \denv \hspace{100mm} \\
  \ext{\env}{\varmeta{s}}{\vals} &= \env'
\end{align*}
with
\[
	\env'(\varmeta) =\begin{cases}
	\loc_i & \textrm{with }\deref{\loc_i} = \val_i\textrm{ if }\exists\varmeta_i \in \varmeta{s} \textrm{ s.t. } \varmeta_i = \varmeta\\
	\env(\varmeta) &\textrm{otherwise}
	\end{cases}
\]

For simpler notation, we allow ``$\extend$'' to be called with singleton lists as $\ext{\env}{\varmeta}{\val}$, which we consider equivalent to $\ext{\env}{\varmeta :: []}{\val :: []}$.
\subsubsection{Variable lookup}
\label{subsubsec:variable-lookup}
A variable lookup consists of looking up the location of a variable from the environment with $\loc = \env(\varmeta)$ and reading the stored value $v$ with $\deref{\loc} = \deref{\env(\varmeta)}$ from the store.
For definition of ``$\deref$'' see Section~\ref{subsubsection:dereferecing}.

\subsection{Configurations}
\label{subsec:cesk-configs}
The state space of the CESK machine contains various kinds of configurations.
Configurations contain different components and the transition step dispatches to the next configuration based on one of the components of the configuration.

% Named Configuration for CESK transitions
\newcommand{\breakconf}[1]{\confsingle{#1}_{\mathrm{breakCont}}}
\newcommand{\switchconf}[1]{\confsingle{#1}_{\mathrm{switchCont}}}
\newcommand{\contconf}[2]{\confpair{#1}{#2}_{\mathrm{cont}}}
\newcommand{\scontconf}[2]{\confpair{#1}{#2}_{\mathrm{scont}}}
\newcommand{\acontconf}[2]{\confpair{#1}{#2}_{\mathrm{acont}}}
\newcommand{\throwconf}[3]{\conftriple{#1}{#2}{#3}_{\mathrm{throw}}}
\newcommand{\evallistconf}[6]{\langle{#1},\,{#2},\,{#3},\handler,\,{#4},\,{#5},\,{#6}\rangle_{\mathrm{evalList}}}
\newcommand{\evalconf}[6]{\langle{#1},\,{#2},\,{#3},\handler,\,{#4},\,{#5},\,{#6}\rangle_{\mathrm{eval}}}
\newcommand{\execconf}[9]{\langle{#1},\,{#2},\,{#3},\,{#4},\,\strace,\,{#5},\,{#6},\,{#7},\,{#8},\,{#9}\rangle_{\mathrm{exec}}}

% Transition
\begin{figure}[Htp]
  \begin{align}
	&\evalconf{\expr}{\env}{st}{cex}{cst}{\econt} & :\quad & \text{EvalConfiguration} \label{config:eval}\\
	&\evallistconf{\exprs}{\env}{st}{cex}{cst}{\acont} & :\quad & \text{EvalListConfiguration} \label{config:evallist}\\
	&\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}  & :\quad & \text{ExecConfiguration} \label{config:exec}\\
	&\contconf{\econt}{\val} & :\quad & \text{ValuePassingConfiguration} \label{config:econt}\\
	&\acontconf{\acont}{\vals} & :\quad & \text{ApplicationConfiguration} \label{config:acont}\\
	&\scontconf{\scont}{\env} & :\quad & \text{ForwardConfiguration} \label{config:scont}\\
	&\throwconf{\handler}{\val}{\strace} & :\quad & \text{ThrowConfiguration} \label{config:throw}\\
	&\breakconf{\bcont} & :\quad & \text{BreakConfiguration} \label{config:bcont}\\
	&\switchconf{\switchcont} & :\quad &
	\text{SwitchConfiguration}
	\label{config:switchcont}
  \end{align}
  \caption{States for the CESK machine}
\end{figure}

\subsubsection{EvalConfiguration}
\label{subsubsec:evalconfig}

The configuration EvalConfiguration is shown in \ref{config:eval}. 
The transition step for this configuration dispatches on the expression component, $\expr$.
With one transition step of the CESK-transition function, from the EvalConfiguration the next configuration can be one of the following:
\begin{itemize}
\item ValuePassingConfiguration, when the current expression evaluates to a value in one step.
\item ExecConfiguration, when the current expression results with an invocation, i.e. execution of statement body of a getter.
Note that for other invocations, we first evaluate the receiver for instance invocations, or the arguments for static or constructor invocations.
\item EvalListConfiguration, when the current expression implies evaluation of a list of expressions.
\item ThrowConfiguration, when the current expression throws, i.e. is a throw expression.
\item EvalConfiguration, otherwise.
\end{itemize}

\subsubsection{EvalListConfigruation}
\label{subsubsec:evallistconfig}
The configuration EvalListConfiguration is shown in \ref{config:evallist}.
The transition step for this configuration dispatches on the expression list, $\exprs$.
With one step of the CESK-transition function, from EvalListConfifuration the next configuration is either EvalConfiguration, when $\exprs \neq []$, or ApplicationConfiguration, otherwise.

\subsubsection{ExecConfiguration}
\label{subsubsec:execconfig}

The configuration ExecConfiguration is shown in \ref{config:exec}.
The transition step dispatches on the statement, $\stmt$.
The next configuration is either EvalConfiguration or ExecConfiguration.

\subsubsection{ValuePassingConfiguration}
\label{suubsubsec:valuepassingconfig}

The configuration ValuePassingConfiguration is shown in \ref{config:econt}.
The transition step applies the expression continuation component to its value component.
The expression continuation produces the next configuration.

\subsubsection{ApplicationConfiguration}
\label{subsubsec:applicationconfig}

The configuration ApplicationConfiguration is shown in \ref{config:acont}.
The transition step applies the application continuation component to its list of values component.
The application continuation produces the next configuration.
\subsubsection{ForwardConfiguration}
\label{subsubsec:forwardconfig}

The configuration ForwardConfiguration is shown in \ref{config:scont}.
The transition step applies the statement continuation component to its environment component.
The statement continuation produces the next configuration.

\subsubsection{ThrowCongfiguration}
\label{subsubsec:throwconfig}
The configuration ThrowConfiguration is shown in \ref{config:throw}.
The transition step applies the exception handler.
The next configuration is:
\begin{itemize}
\item ThrowConfiguration, when the exception is not handled by the first catch clause of a catch handler.
\item ExecConfiguration, for the statement body of the matching catch or the finally statement, when no catch clauses are present.
\end{itemize}
\subsubsection{BreakConfiguration}
\label{subsubsec:breakconfig}
The configuration BreakConfiguration is shown in \ref{config:bcont}.
The transition step applies the break continuation component.
The next configuration is ForwardConfiguration.
\subsubsection{SwitchConfiguration}
\label{subsubsec:switchconfig}

The configuration SwitchConfiguration is shown in \ref{config:switchcont}.
The transition step applies the switch continuation component.
The next configuration is ExecConfiguration.

\subsection{Continuations}
\label{subsec:continuations-definition}

% Metavariables
\newcommand{\expressionmeta}{\ensuremath{\mathit{E}}}
\newcommand{\expressionsmeta}{\expressionmeta{s}}
\newcommand{\variablemeta}{\ensuremath{\mathit{X}}}
\newcommand{\boolmeta}{\ensuremath{\mathit{B}}}
\newcommand{\integermeta}{\ensuremath{\mathit{I}}}
\newcommand{\doublemeta}{\ensuremath{\mathit{D}}}
\newcommand{\stringmeta}{\ensuremath{\mathit{S}}}
\newcommand{\idmeta}{\ensuremath{\mathit{X}}}
\newcommand{\membermeta}{\ensuremath{\mathit{M}}}
\newcommand{\typemeta}{\ensuremath{\mathit{T}}}
% Metavariables for statements
\newcommand{\statementmeta}{\ensuremath{\mathit{\stmt}}}
\newcommand{\labelmeta}{\ensuremath{\mathit{\tt{L}}}}

Continuations represent the instructions for execution of statements or evaluation of expressions.
They capture the information needed to resume the execution of the program.
There are various types of continuations depending on the state for evaluation of an expression or execution of a statement.
\subsubsection{Expression continuations}
\label{subsubsec:expression-continuations}

Expression continuations, $\econt$, capture the steps after the evaluation of a given expression.
They accept a value and produce the next configuration.

There are various kinds of configurations, but two more general types can be distinguished:
\begin{itemize}
\item Continuations with holes, i.e. expressions to be evaluated\\
Expression continuations with expressions will produce EvalConfiguration for evaluation of the next expression.
Note that some continuation will not evaluate the captured expression, when this is not necessary (e.g., \ref{eval:bool-expressions}).

\item Continuations without holes\\
Continuations without holes dispatch on the provided value and produce the next configuration, a ValuePassingConfiguration.
\end{itemize}
We suffix the names of expression continuations with ``$K$''.
The different expression continuations are shown in Figure~\ref{figure:econts}.
%
\newcommand{\ExceptionHandlersRest}{\handler,\,\cstrace,\,\cex}
\newcommand{\ExceptionHandlers}{\strace,\,\handler,\,\cstrace,\,\cex}
% Continuations
\newcommand{\VarSetK}[3]{\mathrm{VarSetK}({#1},\,{#2},\,{#3})}
\newcommand{\ExpressionsK}[3]{\mathrm{ExpressionsK}({#1},\,{#2},\,\ExceptionHandlers,\,{#3})}
%
\newcommand{\NotK}[1]{\mathrm{NotK}({#1})}
\newcommand{\AndK}[3]{\mathrm{AndK}({#1},\,{#2},\,\ExceptionHandlers,\,{#3})}
\newcommand{\OrK}[3]{\mathrm{OrK}({#1},\,{#2},\,\ExceptionHandlers,\,{#3})}
\newcommand{\ConditionalK}[4]{\mathrm{ConditionalK}({#1},\,{#2},\,{#3},\,\ExceptionHandlers,\,{#4})}
%
\newcommand{\LetK}[4]{\mathrm{LetK}({#1},\,{#2},\,{#3},\,\ExceptionHandlers,\,{#4})}
%
\newcommand{\IsExpressionK}{\mathrm{IsExpressionK}(\tt{T},\,\econt)}
\newcommand{\AsExpressionK}{\mathrm{AsExpressionK}(\tt{T},\,\strace,\,\handler,\,\econt)}
%
\newcommand{\StaticGetK}{\mathrm{StaticGetK}(\membermeta,\,\econt)}
\newcommand{\StaticSetK}{\mathrm{StaticSetK}(\membermeta,\,\econt)}
\newcommand{\PropertyGetK}{\mathrm{PropertyGetK}(\idmeta,\,\ExceptionHandlers,\,\econt)}
\newcommand{\PropertySetK}{\mathrm{PropertySetK}(\idmeta,\,\expressionmeta_1,\,\env,\,\ExceptionHandlers,\,\econt)}
\newcommand{\PropertySetVK}{\mathrm{PropertySetValueK}(\val_0,\,\idmeta,\,\ExceptionHandlers\,\econt)}
\newcommand{\DPropertyGetK}{\mathrm{DPropertyGetK}(\membermeta,\,\ExceptionHandlers,\,\econt)}
\newcommand{\DirectPropertySetK}{\mathrm{DPropertySetK}(\membermeta,\,\expressionmeta_1,\,\env,\,\ExceptionHandlers,\,\econt)}
\newcommand{\DPropertySetVK}{\mathrm{DPropertySetValueK}(\val_0,\,\membermeta,\,\ExceptionHandlers,\,\econt)}
\newcommand{\SuperPropertySetK}{\mathrm{SuperPropertySetK}(\idmeta,\,\env,\,\ExceptionHandlers,\,\econt)}
%
\newcommand{\InstanceMethodK}{\mathrm{InstanceMethodK(\expressionsmeta,\,\idmeta,\,\env,\,\ExceptionHandlers,\,\econt)}}
\newcommand{\DInstanceMethodK}{\mathrm{DInstanceMethodK}(\expressionsmeta,\,\membermeta,\,\env,\,\ExceptionHandlers,\,\econt)}
\newcommand{\VarDeclK}[3]{\mathrm{VarDeclarationK}({#1},\,{#2},\,{#3})}
\newcommand{\IfCondK}[2]{\mathrm{IfConditionK}({#1},\,{#2},\,\env,\,\lbls,\,\clbls,\,\handler,\,\cstrace,\,\cex,\,\econt,\,\scont)}
\newcommand{\SwitchK}[2]{\mathrm{SwitchK}({#1},\,\env,\,\lbls,\,{#2},\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt,\,\scont)}
%
\newcommand{\whilecondk}{\mathrm{WhileCondK}(\expr,\,\stmt,\,\env,\,\lbls,\,\clbls,\,\handler,\,\cstrace,\,\cex,\,\econt,\,\scont)}
\newcommand{\InitializerK}[4]{\mathrm{InitializerK}({#1},\,{#2},\,{#3},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#4})}
\newcommand{\InitK}[3]{\mathrm{InitiK}({#1},\,{#2},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#3})}
\newcommand{\FinallyK}[1]{\mathrm{Finally}({#1},\,\env,\,\lbls,\,\clbls,\,\strace,\,\handler,\,\econt)}
\newcommand{\FinallyReturnK}[1]{\mathrm{FinallyReturnK}({#1},\,\env,\,\lbls,\,\clbls,\,\strace,\,\handler,\,\econt)}
%
%
\newcommand{\ForCondK}{\mathrm{ForCondK}(\mathrm{\varmeta{s}},\, \expressionmeta,\, \exprs,\, \statementmeta,\, \env,\, \env',\, \lbls,\, \clbls,\, \handler,\, \cstrace,\, \cex,\, \econt,\, \scont)}

\begin{figure}[Htp]
  \begin{align}
	&\VarSetK{\idmeta}{\ExceptionHandlers}{\econt} \label{econt:varset}\\
	&\ExpressionsK{\exprs}{\env}{\acont} \label{econt:expressions}\\
	&\NotK{\econt} \label{econt:not}\\
	&\AndK{\expressionmeta}{\ExceptionHandlers}{\econt} \label{econt:and}\\
	&\OrK{\expressionmeta}{\ExceptionHandlers}{\econt} \label{econt:or}\\
	&\ConditionalK{\expressionmeta_1}{\expressionmeta_2}{\ExceptionHandlers}{\econt} \label{econt:cond}\\
	&\LetK{\idmeta}{\expressionmeta}{\ExceptionHandlers}{\econt} \label{econt:let}\\
	&\IsExpressionK \label{econt:is}\\
	&\AsExpressionK \label{econt:as}\\
	&\StaticGetK \label{econt:static-get}\\
	&\StaticSetK \label{econt:static-set}\\
	&\DPropertyGetK \label{econt:dproperty-get}\\
	&\PropertySetK \label{econt:property-set}\\
	&\PropertySetVK \label{econt:property-set}\\
	&\DPropertyGetK \label{econt:dproperty-set}\\
	&\DPropertySetVK \label{econt:dproperty-set-v}\\
	&\SuperPropertySetK \label{econt:super-property-set}\\
	&\InstanceMethodK \label{econt:instance-method}\\
	&\DInstanceMethodK \label{econt:dinstance-method}\\
	&\VarDeclK{\idmeta}{\env}{\scont} \label{econt:var-decl}\\
	&\IfCondK{\expressionmeta_1}{\expressionmeta_2} \label{econt:if-cond}\\
	&\ForCondK \label{econt:for-cond}
  \end{align}
  \caption{Expression Continuations}
  \label{figure:econts}
\end{figure}

\subsubsection{Statement continuations}
\label{subsubsec:statement-continuations}

Statement continuations, $\scont$, capture the steps after execution of a statement.
They accept an environment and produce the next configuration.
Statements in a block expressions can extend the environment function and this is visible to the subsequent statements in the same block.
For other types of statement configuration, the environment is ignored.

\noindent
We suffix the names of statement continuations with ``$SK$''.
The different statement continuations are shown in Figure~\ref{figure:sconts}.
\newcommand{\ExitSK}[1]{\mathrm{ExitSK(\econt,\,#1)}}
\newcommand{\BlockSK}[2]{\mathrm{BlockSK}({#1},\,{#2},\,\lbls,\,\clbls,\,\handler,\,\cstrace,\,\cex,\,\econt,\,\scont)}
\newcommand{\WhileSK}{\mathrm{WhileSK}(\expr,\,\stmt,\,\env,\,\lbls,\,\clbls,\,\handler,\,\cstrace,\,\cex,\,\econt,\,\scont)}
\newcommand{\BodySK}[3]{\mathrm{BodySK}({#1},\,{#2},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#3})}
\newcommand{\NewSK}[2]{\mathrm{NewSK}({#1},\,{#2})}
\newcommand{\FinallySK}[1]{\mathrm{FinallySK}({#1},\,\env,\,\lbls,\,\clbls,\,\strace,\,\handler,\,\econt,\,\scont)}
\newcommand{\RethrowSK}[3]{\mathrm{RethrowSK}({#1},\,{#2},\,{#3})}
%
\newcommand{\ForSK}{\mathrm{ForSK}(\mathrm{\varmeta{s}},\, \expressionmeta,\, \exprs,\, \statementmeta,\, \env,\, \env',\, \lbls,\, \clbls,\, \handler,\, \cstrace,\, \cex,\, \econt,\, \scont)}
\begin{figure}[Htp]
  \begin{align}
	&\ExitSK{\val} \label{scont:exit}\\
	&\BlockSK{\stmts}{\env} \label{scont:block}\\
	&\WhileSK \label{scont:while}\\
	&\BodySK{\stmt}{\env}{\scont} \label{scont:body}\\
	&\NewSK{\econt}{\loc} \label{scont:new}\\
	&\FinallySK{\stmt} \label{scont:finally}\\
	&\RethrowSK{\val}{\strace}{\handler} \label{scont:rethrow}\\
	&\ForSK \label{scont:for}
  \end{align}
  \caption{Statement Continuations}
  \label{figure:sconts}
\end{figure}

\subsubsection{Application continuation}
\label{subsubsec:application-continuation}

Application continuations, $\acont$, capture the application of a list of values resulting from the evaluation of list of expressions.

\newcommand{\ValueA}[2]{\mathrm{ValueA}({#1},\,{#2})}
\newcommand{\StringConcatenationA}{\mathrm{StringConcatenationA(\econt)}}
\newcommand{\SuperMethodA}{\mathrm{SuperMethodA}(\idmeta,\,\env,\,\ExceptionHandlers,\,\econt)}
\newcommand{\StaticInvA}[4]{\mathrm{StaticInvocationA}({#1},\,{#2},\,{#3},\,\ExceptionHandlersRest,\,{#4})}
\newcommand{\DInstanceMethodA}{\mathrm{DInstanceMethodA}(\membermeta,\,\val,\,\ExceptionHandlers,\,\econt)}
\newcommand{\FieldsA}[4]{\mathrm{FieldsA}({#1},\,{#2},\,{#3},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#4})}
\newcommand{\SuperA}[3]{\mathrm{SuperA}({#1},\,{#2},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#3})}
\newcommand{\ConstructorA}[2]{\mathrm{ConstructorA}({#1},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#2})}
\newcommand{\RedirectingA}[3]{\mathrm{RedirectingA}({#1},\,{#2},\,\strace,\,\handler,\,\cstrace,\,\cex,\,{#3})}
\newcommand{\ForInitA}{\mathrm{ForInitA}(\mathrm{\varmeta{s}},\, \expressionmeta,\, \exprs,\, \statementmeta,\, \env,\, \lbls,\, \clbls,\, \handler,\, \cstrace,\, \cex,\, \econt,\, \scont)}
%
\newcommand{\ForUpdatesA}[1]{\mathrm{ForUpdatesA}(\mathrm{\varmeta{s}},\, \expressionmeta,\, \exprs,\, \statementmeta,\, \env,\, #1,\, \lbls,\, \clbls,\, \handler,\, \cstrace,\, \cex,\, \econt,\, \scont)}
\noindent
We use the application continuation $\ValueA{\acont}{\val}$, capturing a value and an application continuation, as application that adds a value to the list of values to eventually used by an application continuation that produces a configuration other than ApplicationConfiguration.\\
\noindent
We suffix the names of application continuations with ``$A$''.
The different application continuations are shown in Figure~\ref{figure:acont}.
\begin{figure}[Htp]
  \begin{align}
	&\ValueA{\val}{\acont} \label{acont:value}\\
	&\StringConcatenationA \label{acont:stringconcat}\\
	&\ForInitA \label{acont:forinit}\\
	&\ForUpdatesA{\env'} \label{acont:forupdates}\\
	&\SuperMethodA \label{acont:supermethod}\\
	&\DInstanceMethodA \label{acont:staticinv}\\
	&\FieldsA{\env}{Izs}{\loc}{\scont} \label{acont:fields}\\
	&\ConstructorA{Q}{\econt} \label{acont:constructor}\\
	&\SuperA{Q}{\loc}{\scont} \label{acont:super}\\
	&\RedirectingA{Q}{\loc}{\scont} \label{acont:redirecting}
  \end{align}
  \caption{Application Continuations}
  \label{figure:acont}
\end{figure}

\subsubsection{Break continuations}
\label{subsubsec:break-continuations}

Break continuations, $\bcont$, capture the steps to be executed when a break to a given label is encountered.
The different break continuations are shown in Figure~\ref{figure:breakcont}.
\newcommand{\Break}[2]{\mathrm{Break}(#1,\,#2)}
\newcommand{\FinallyBreak}[2]{\mathrm{FinallyBreak}({#1},\,\env,\,\lbls,\,\clbls,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt,\,{#2})}

\begin{figure}[Htp]
  \begin{align}
    &\Break{\env}{\scont} \label{breakcont:break} \\
    &\FinallyBreak{\stmt}{\scont} \label{breakcont:finallybreak}
  \end{align}
  \caption{Break Continuations}
  \label{figure:breakcont}
\end{figure}
\noindent
The break continuation Break, \ref{breakcont:break}, captures a statement continuation and the environment corresponding to a target label or a break statement.\\
The break continuation FinallyBreak, \ref{breakcont:finallybreak}, captures the statement body and the components necessary for the execution of an enclosing Finally statement. 
They are added when a try/finally statement is executed.
\subsubsection{Switch continuations}
\label{subsubsec:switch-continuations}

Switch continuations, $\switchcont$, capture the steps to be executed when a continue to a preceding switch case statement is executed.
They capture the components needed for the execution of the case body statement.
The different switch continuations are shown in Figure~\ref{figure:switchconts}.
%
\newcommand{\ContinueK}{\mathrm{SwitchContinueK}(\stmt,\,\env,\,\lbls,\,\clbls,\,\handler,\,\cstrace,\,\cex,\,\econt,\,\scont)}
\newcommand{\FinallyContinue}[2]{\mathrm{FinallyContinue}({#1},\,\env,\,\lbls,\,\clbls,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt,\,{#2})}

\begin{figure}[Htp]
  \begin{align}
    &\ContinueK \label{switchcont:continue} \\
    &\FinallyContinue{\stmt}{\scont} \label{switchcont:finallycontinue}
  \end{align}
  \caption{Switch Continuations}
  \label{figure:switchconts}
\end{figure}
\noindent
The switch continuation SwitchContinue, \ref{switchcont:continue}, captures the statement body of a preceding switch case, targeted by some continue statement, and the components necessary for its execution.
The switch continuation FinallyContinue, \ref{switchcont:finallycontinue}, captures the statement body and the components necessary for the execution of an enclosing Finally statement.
They are added when a try/finally statement is executed.
\subsubsection{Exception handlers}
\label{subsubsec:exception-handlers}
The different exception handlers are shown in Figure~\ref{figure:handlers}.
\newcommand{\ThrowH}[2]{\mathrm{ThrowK}({#1},\,{#2})}
\newcommand{\CatchH}[1]{\mathrm{Catch}({#1},\,\env,\,\lbls,\,\clbls,\,\strace,\,\handler,\,\econt,\,\scont)}

\begin{figure}[Htp]
  \begin{align}
    &\ThrowH{\val}{\strace} \label{handle:throw} \\
    &\CatchH{cs} \label{handle:catch}
  \end{align}
  \caption{Exception handlers}
  \label{figure:handlers}
\end{figure}

\section{Values}
\label{sec:values}
\subsection{Literal values}
\label{subsubsec:literal-values}
Literal values are special values that store the specific payload and an associated class.
The different literal values are presented below: 
\[
  \begin{array}{lcl}
	\val \in \dlitval &=& \mathbf{int} + \mathbf{bool} + \mathbf{double}\\
	&& + \mathbf{List} + \mathbf{Map} + \mathbf{String} + \mathbf{Symbol} + \mathbf{Type}
  \end{array}
\]
Each of the specific literal values contains predefined operators and/or methods, whose semantics we are not going to specify in this document.
\subsection{Object values}
\label{subsec:object-values}
Object values are represented as follows:
\[
	\dobjval : \dclass \times \mlist{\dlocation}\\
\]
Object values have the following properties: class, lookup, lookupMethod. % TBD
\subsubsection{Class}
\label{subsubsec:class}

\[
\dclass : superclass \times interfaces \times fields \times getters \times setters \times methods
\]
\subsubsection{Property Lookup}
\label{subsubsec:property-lookup}


% lookup getters 
% lookup implicit getters
\subsubsection{Method Lookup}
\label{subsubsec:method-lookup}
% lookup method
\subsubsection{Superclass}
\label{subsubsec:superclass}

\subsection{Function values}
\label{subsec:function-values}
\[
	\dfunval : \dformals \times \dstmt \times \denv
\]

\section{Abstract Syntax}
\label{sec:abstract-syntax}

\subsubsection{Expressions}
\label{sec:expr-syntax}

% Syntax
\newcommand{\VariableGet}[1]{#1}
\newcommand{\VariableSet}[2]{#1=#2}

% TODO(kmillikin): Names should not ignore the library.
\newcommand{\PropertyGet}[2]{#1.#2}
\newcommand{\PropertySet}[3]{#1.#2=#3}

\newcommand{\DirectPropertyGet}[2]{#1.\{#2\}}
\newcommand{\DirectPropertySet}[3]{#1.\{#2\}=#3}

\newcommand{\SuperPropertyGet}[1]{\tt{super}.#1}
\newcommand{\SuperPropertySet}[2]{\tt{super}.#1=#2}

\newcommand{\StaticGet}[1]{#1}
\newcommand{\StaticSet}[2]{#1=#2}

%% MethodInvocation
\newcommand{\InstanceMethodInvocation}[3]{#1.#2(#3)}
%% DirectMethodInvocation
\newcommand{\DInstanceMethodInvocation}[3]{#1.\{#2\}(#3)}
%% SuperMethodInvocation
\newcommand{\SuperMethodInvocation}[2]{\tt{super}.#1(#2)}
%% StaticInvocation
\newcommand{\StaticInvocation}[2]{#1(#2)}
%% ConstructorInvocation

\newcommand{\Not}[1]{!#1}
\newcommand{\AndExpression}[2]{#1\,\&\&\,#2}
\newcommand{\OrExpression}[2]{#1\,||\,#2}
\newcommand{\ConditionalExpression}[3]{#1\,?\,#2\,:\,#3}

%% StringConcatenation
\newcommand{\StringConcatenation}[1]{\tt{Concat}\,#1}

\newcommand{\IsExpression}[2]{#1\,\tt{is}\,#2}
\newcommand{\AsExpression}[2]{#1\,\tt{as}\,#2}

%% SymbolLiteral
%% TypeLiteral

\newcommand{\ThisExpression}{\tt{this}}
\newcommand{\Rethrow}{\tt{rethrow}}
\newcommand{\Throw}[1]{\tt{throw}\,#1}

%% ListLiteral
%% MapLiteral

\newcommand{\AwaitExpression}[1]{\tt{await\,#1}}

%% FunctionExpression

\newcommand{\StringLiteral}[1]{#1}
\newcommand{\IntLiteral}[1]{#1}
\newcommand{\DoubleLiteral}[1]{#1}
\newcommand{\BoolLiteral}[1]{#1}
\newcommand{\NullLiteral}{\tt{null}}
\newcommand{\Let}[3]{\tt{let}\,#1=#2\,\tt{in}\,#3}

%% LoadLibrary
%% CheckLibraryIsLoaded
%% VectorCreation
%% VectorGet
%% VectorSet
%% VectorCopy
%% ClosureCreation
%% TypeInstantiation

\[
\begin{array}{rl}
  \expressionmeta \in \mathit{Expression} ::=
  & \VariableGet{\variablemeta} \\
  & \VariableSet{\variablemeta}{\expressionmeta} \\
  & \PropertyGet{\expressionmeta}{\idmeta} \\
  & \PropertySet{\expressionmeta_0}{\idmeta}{\expressionmeta_1} \\
  & \DirectPropertyGet{\expressionmeta}{\membermeta} \\
  & \DirectPropertySet{\expressionmeta_0}{\membermeta}{\expressionmeta_1} \\
  & \SuperPropertyGet{\idmeta} \\
  & \SuperPropertySet{\idmeta}{\expressionmeta} \\
  & \StaticGet{\membermeta} \\
  & \StaticSet{\membermeta}{\expressionmeta} \\
  & \Not{\expressionmeta} \\
  & \AndExpression{\expressionmeta_0}{\expressionmeta_1} \\
  & \OrExpression{\expressionmeta_0}{\expressionmeta_1} \\
  & \ConditionalExpression{\expressionmeta_0}{\expressionmeta_1}{\expressionmeta_2} \\
  & \IsExpression{\expressionmeta}{\typemeta} \\
  & \AsExpression{\expressionmeta}{\typemeta} \\
  & \ThisExpression \\
  & \Rethrow \\
  & \Throw{\expressionmeta} \\
  & \AwaitExpression{\expressionmeta} \\
  & \StringLiteral{\stringmeta} \\
  & \IntLiteral{\integermeta} \\
  & \DoubleLiteral{\doublemeta} \\
  & \BoolLiteral{\tt{true}} \\
  & \BoolLiteral{\tt{false}} \\
  & \NullLiteral \\
  & \Let{\variablemeta}{\expressionmeta_0}{\expressionmeta_1} \\
\end{array}
\]
\subsection{Statements}
\label{subsec:stmt-syntax}
% InvalidStatement
%
\newcommand{\ExpressionStatement}[1]{\{\, #1\, \}}
\newcommand{\Block}[1]{#1\, \statementmeta*}
\newcommand{\EmptyStatement}{\{\}}
%
% AssertStatement
%
\newcommand{\LabeledStatement}[2]{#1:\, #2}
\newcommand{\BreakStatement}[1]{\tt{break}\, #1}
\newcommand{\WhileStatement}[2]{\tt{while}\, (#1)\, #2}
\newcommand{\DoStatement}[2]{\tt{do}\, #1\, \tt{while}\, (#2)}
\newcommand{\ForStatement}[4]{\tt{for}\, (\,#1;\, #2;\, #3\,)\, #4}
\newcommand{\ForInStatement}[3]{\tt{for}\,(#1\,\tt{in}\,#2)\,#3}
%
\newcommand{\SwitchStatement}[2]{\tt{switch}\,(#1)\,#2}
\newcommand{\ContinueSwitchStatement}[1]{\tt{continue}\,#1}
\newcommand{\IfStatement}[3]{\tt{if}\,(#1)\,#2\,\tt{else}\,#3}
\newcommand{\ReturnStatement}[1]{\tt{return}\,#1}
%
\newcommand{\TryCatch}[2]{\tt{try}\,#1\,\tt{catch}\,#2}
\newcommand{\TryFinally}[2]{\tt{try}\,#1\,\tt{catch}\,#2}
%
\newcommand{\Yield}[1]{\tt{yield}\,#1}
%
\newcommand{\VarDeclaration}[2]{\tt{var}\,#1=#2}
%
% FunctionDeclaration
%
\[
\begin{array}{rl}

  \statementmeta \in \mathit{Statements} ::=
  & \ExpressionStatement{\expressionmeta} \\
  & \Block{\statementmeta} \\
  & \EmptyStatement \\
  & \LabeledStatement{\labelmeta}{\statementmeta} \\
  & \BreakStatement{\labelmeta} \\
  & \WhileStatement{\expressionmeta}{\statementmeta} \\
  & \DoStatement{\statementmeta}{\expressionmeta} \\
  & \ForStatement{??}{\expressionmeta}{??}{\statementmeta} \\
  & \ForInStatement{\idmeta}{\expressionmeta}{\statementmeta} \\
  & \SwitchStatement{\expressionmeta}{\tt{SCs}} \\
  & \ContinueSwitchStatement{\statementmeta} \\
  & \IfStatement{\expressionmeta}{\statementmeta_1}{\statementmeta_2} \\
  & \ReturnStatement{\expressionmeta} \\
  & \ReturnStatement{} \\
  & \TryCatch{\statementmeta}{\tt{CCs}} \\
  & \TryFinally{\statementmeta_1}{\statementmeta_2} \\
  & \Yield{\expressionmeta} \\
  & \VarDeclaration{\idmeta}{\expressionmeta} \\

\end{array}
\]

\section{Semantics}
\label{sec:semantics}
\subsection{Expression evaluation}
\label{subsec:expr-evaluation}
\newcommand{\this}{\tt{this}}
\newcommand{\superclass}[1]{superclass({#1})}

Expressions are evaluated by dispatching according to the expression component, $\expressionmeta$, in EvalConfiguration, Section~\ref{subsubsec:evalconfig}, and the list of expression component, $\exprs$, in EvalListConfiguration, Section~\ref{subsubsec:evallistconfig}.

\noindent
The CESK-transition function for EvalListConfiguration is shown in Figure~\ref{figure:evallist}.
The value corresponding to the evaluated expression is captured by the application continuation ValueA and eventually added to the list of values corresponding to the expressions.

\begin{figure}[Htp]
    \begin{align}
    &\begin{multlined}
        \cesktranswheresplit%
            {\evallistconf{\expr :: \exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}}%
            {\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
            {\text{where $\econt' = \ExpressionsK{\exprs}{\env}{\acont}$}}
    \end{multlined}\\
    &\cesktrans%
        {\evallistconf{[]}{\env}{\strace}{\cstrace}{\cex}{\acont}}%
        {\acontconf{\acont}{[]}}\\
    &\cesktrans%
        {\acontconf{\ValueA{\val}{\acont}}{\val s}}%
        {\acontconf{\acont}{\val :: \val s}}
    \end{align}
  \caption{The CESK-transition function for EvalListConfiguration}\label{figure:evallist}
  \label{subsec:eval-list-expressions}
\end{figure}

%%
% Figure showing the CEK-transition function starting from EvalConfiguration for simple 
% expressions.
%%
\begin{figure}[Htp]
	\begin{align}
        &\cesktranswhere%
			{\evalconf{\IntLiteral{\integermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\contconf{\econt}{\val}}%
            {\text{where $\val = \mathrm{IntLiteral(\integermeta)} \in \mathbf{int}$}}
            \label{eval:int}\\
        &\cesktranswhere%
			{\evalconf{\DoubleLiteral{\doublemeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\contconf{\econt}{\val}}%
            {\text{where $\val = \mathrm{DoubleLiteral(\doublemeta)} \in \mathbf{double}$}}
            \label{eval:double}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\BoolLiteral{\tt{true}}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\contconf{\econt}{\val}}%
                {\text{where $\val = \mathrm{BoolValue(\tt{true})} = \tt{true}\in \mathbf{bool}$}}
        \end{multlined}
        \label{eval:true}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\BoolLiteral{\tt{false}}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\contconf{\econt}{\val}}%
                {\text{where $\val = \mathrm{BoolValue(\tt{false})} = \tt{false}\in \mathbf{bool}$}}
        \end{multlined}
        \label{eval:false}\\
        &\cesktranswhere%
            {\evalconf{\StringLiteral{\stringmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\contconf{\econt}{\val}}%
            {\text{where $\val = \mathrm{StringValue(\stringmeta)} \in \mathbf{String}$}}
            \label{eval:string}\\
        &\cesktrans%
            {\evalconf{\varmeta}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\contconf{\econt}{\deref{\env(\varmeta)}}}
            \label{eval:varget}\\
        &\cesktrans%
            {\evalconf{\varmeta = \expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\VarSetK{\env}{\varmeta}{\econt}}}
            \label{eval:varset}\\
        &\cesktrans%
            {\evalconf{\Not{\expressionmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\NotK{\econt}}}
            \label{eval:not}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\AndExpression{\expressionmeta_0}{\expressionmeta_1}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expressionmeta_0}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
                {\text{where $\econt' = \AndK{\expri{2}}{\env}{\econt}$}}%
        \end{multlined}
        \label{eval:and}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\OrExpression{\expressionmeta_0}{\expressionmeta_1}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expressionmeta_0}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
                {\text{where $\econt' = \OrK{\expri{2}}{\env}{\econt}$}}%
        \end{multlined}
        \label{eval:or}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\ConditionalExpression{\expr}{\expri{1}}{\expri{2}}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
                {\text{where }\econt' = \ConditionalK{\expri{1}}{\expri{2}}{\env}{\econt}}
        \end{multlined}
        \label{eval:cond}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\Let{\varmeta}{\expri{1}}{\expri{2}}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
                {\text{where }\econt' = \LetK{\expri{2}}{\env}{\varmeta}{\econt}}
        \end{multlined}
        \label{eval:let}\\
        &\begin{multlined}
            \cesktranssplit%
                {\evalconf{\StringConcatenation{\exprs}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\StringConcatenationA}}
        \end{multlined}
        \label{eval:concat}\\
        &\cesktrans%
            {\evalconf{\IsExpression{\expressionmeta}{\tt{T}}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\IsExpressionK}}
          \label{eval:is}\\
        &\begin{multlined}
            \cesktranssplit%
                {\evalconf{\AsExpression{\expressionmeta}{\tt{T}}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\AsExpressionK}}
        \end{multlined}
        \label{eval:as}\\
        &\cesktrans%
            {\evalconf{\ThisExpression}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\contconf{\econt}{\deref{\env(\this)}}}
            \label{eval:this}\\
        &\begin{multlined}
            \cesktranssplit%
                {\evalconf{\textbf{throw } \expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\ThrowH{(\textbf{throw } \expr) :: \strace}{\handler}}}
        \end{multlined}
        \label{eval:throw}\\
        &\cesktrans%
            {\evalconf{\textbf{rethrow}}{\env}{\strace}{inr(\val)}{\strace'}{\econt}}%
            {\throwconf{\handler}{\val}{\strace'}}
            \label{eval:rethrow}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{F}{\env}{st}{cex}{cst}{\econt}}%
                {\contconf{\econt}{\funval{\formals}{\stmt}{\env}}}%
                {\text{where $F$ is a function expression with formal parameters $\formals$ and body $\stmt$}}
        \end{multlined}
	\end{align}
	\caption{The CESK-transition function for EvalConfiguration: simple expressions}
	\label{figure:expressions-evalconfigs}
\end{figure}
%
\newcommand{\true}{\tt{true}}
\newcommand{\false}{\tt{false}}
%%
% Figure showing the CESK-transition function strating from ValuePassingConfiguration
% for simple expressions
%%
\begin{figure}[Htp]
	\begin{align}
		&\begin{multlined}
        \cesktranssplit%
            {\contconf{\ExpressionsK{\exprs}{\env}{\acont}}{\val}}%
            {\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\ValueA{\val}{\acont}}}
        \end{multlined}
        \label{econtconf:exprs}\\
		&\cesktranswhere%
			{\contconf{\VarSetK{\env}{\varmeta}{\econt}}{\val}}%
			{\contconf{\econt}{\val}}%
			{\deref{\env(\varmeta)} = \val \text{ after transition}}
			\label{econtconf:varset}\\
		&\cesktrans%
			{\contconf{\NotK{\econt}}{\true}}%
			{\contconf{\econt}{\false}}
        \label{econtconf:not-true}\\
		&\cesktrans%
			{\contconf{\NotK{\econt}}{\false}}%
			{\contconf{\econt}{\true}}
        \label{econtconf:not-false}\\
		&\cesktrans%
			{\contconf{\AndK{\expressionmeta}{\env}{\econt}}{\true}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt}}
        \label{econtconf:and-true}\\
		&\cesktrans%
			{\contconf{\AndK{\expressionmeta}{\env}{\econt}}{\false}}%
			{\contconf{\econt}{\false}}
        \label{econtconf:and-false}\\
		&\cesktrans%
			{\contconf{\OrK{\expressionmeta}{\env}{\econt}}{\false}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt}}
        \label{econtconf:or-false}\\
		&\cesktrans%
			{\contconf{\OrK{\expressionmeta}{\env}{\econt}}{\true}}%
			{\contconf{\econt}{\true}}
        \label{econtconf:or-true}\\
		&\begin{multlined}
		\cesktranssplit%
			{\contconf{\ConditionalK{\expri{1}}{\expri{2}}{\env}{\econt}}{\true}}%
			{\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt}}
        \end{multlined}
        \label{econtconf:cond-true}\\
		&\begin{multlined}
		\cesktranssplit%
			{\contconf{\ConditionalK{\expri{1}}{\expri{2}}{\env}{\econt}}{\false}}%
			{\evalconf{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}}
        \end{multlined}
        \label{econtconf:cond-false}\\
		&\begin{multlined}
		\cesktranswheresplit%
			{\contconf{\LetK{\expri{2}}{\env}{\varmeta}{\econt}}{\val}}%
			{\evalconf{\expri{2}}{\env'}{\strace}{\cstrace}{\cex}{\econt}}%
			{\env'=\ext{\env}{\varmeta}{\val}}
        \end{multlined}
        \label{econtconf:let}\\
        &\cesktranswhere%
			{\contconf{\IsExpressionK}{\val}}%
			{\contconf{\econt}{\true}}%
			{\text{if $\val \textrm{ is } \tt{T}$}}
		\label{econtconf:is-true}\\
		&\cesktranswhere%
			{\contconf{\IsExpressionK}{\val}}%
			{\contconf{\econt}{\false}}%
			{\text{otherwise}}
		\label{econtconf:is-false}\\
		&\cesktranswhere%
			{\contconf{\AsExpressionK}{\val}}%
			{\contconf{\econt}{\val}}%
			{\text{if $\val \textrm{ is } \tt{T}$}}
		\label{econtconf:as-true}\\
		&\cesktranswhere%
			{\contconf{\AsExpressionK}{\val}}%
			{\throwconf{\handler}{\AsExpression{\expressionmeta}{\tt{T}} :: \strace}{\tt{CastError}}}%
			{\text{if $\val \textrm{ is not } \tt{T}$}}
		\label{econtconf:as-false}
	\end{align}
	\caption{The CESK-transition function for ValuePassingConfiguration: simple expressions}
	\label{figure:cont-config}
\end{figure}
\subsubsection{Basic literal evaluation}
\label{subsubsec:basic-literal-eval}

Kernel literals are evaluated to a value $\val \in \dlitval$ in one step.
Transitions of the CESK machine for basic literals are presented in Figure~\ref{figure:expressions-evalconfigs}, rules \eqref{eval:int} - \eqref{eval:string}.

\subsubsection{Variable assignment and lookup}
\label{subsubsec:variable-assignment-and-lookup}
A variable $\varmeta$ is accessed by reading the value stored at location $\env(\varmeta)$ in the store, \eqref{eval:varget}.\\[2mm]
Assigning a value to a variable $\varmeta$ will modify the store, more specifically the value stored at location  $\env(\varmeta)$.
The evaluation of this expression proceeds by evaluating the right-hand side expression, as shown in \eqref{eval:varset} and setting the location $\env(\varmeta)$ in the store to the value this expression evaluates to, as shown in \eqref{econtconf:varset}.

\subsubsection{Boolean expressions}
\label{subsubsec:bool-expressions}
The CESK-transition function for boolean expressions is show in Figure~\ref{figure:expressions-evalconfigs}, rules \eqref{eval:not} - \eqref{eval:cond}.
\begin{itemize}
\item Not expression\\
The target expression is evaluated, as shown in \eqref{eval:not} and proceed by dispatching on the value the expression evaluates to according to \eqref{econtconf:not-true} and \eqref{econtconf:not-false}.
\item And expression\\
The left-hand side expression is evaluated, according to \eqref{eval:and}.
We dispatch on the value the expression evaluates to.
If the expression evaluate to $\false$, according to \eqref{econtconf:and-false}, the value is immediately applied to the current expression continuation.
Otherwise, we proceed with the CESK-transition \eqref{econtconf:and-true}, by also evaluating the right-hand side.
\item Or expression\\
The left-hand side expression is evaluated, as shown in the CESK-transition \eqref{eval:or}.
We dispatch on the value the expression evaluates to.
If the expression evaluates to $\true$, according to \eqref{econtconf:or-true}, the value is immediately applied to the current expression continuation.
Otherwise, we proceed with the CESK-transition \eqref{econtconf:or-false}, by also evaluating the right-hand side.
\item Conditional expression\\
The condition expression is evaluated, as shown in the CESK-transition \eqref{eval:cond}.
We dispatch on the value the expression evaluates to.
If the expression evaluates to $\true$, the next configuration evaluates the first expression and is produced with the CESK-transition \eqref{econtconf:cond-true}.
Otherwise, the next configuration evaluates the second expression and is produced with the transition \eqref{econtconf:cond-false}.
\end{itemize}
\subsubsection{Let}
Let expressions in Kernel introduce a new variable, initialized to some value with an initializer expression, for the evaluation of the right-hand side let expression.
Let expressions are evaluated by first evaluating the initializer expression for the fresh variable as shown in the CESK-transition \eqref{eval:let}.
It proceeds by extending the environment for the evaluation of the right-hand side let expression and producing the next configuration for evaluation of the later with the CESK-transition \eqref{econtconf:let}.
\subsubsection{String Concatenation}
\label{subsubsec:string-concatenation}
The function $\concat$ concatenates the strings from the given meta-list into a single value.
\begin{align*}
  \concat : \mlist{\dstring} &\rightarrow \dstring \hspace{100mm} \\
  \concat( s_1 :: \dots :: s_n :: []) &= s_1 \dots s_n
\end{align*}
The evaluation of concatenation expression proceeds by evaluating the target expressions in the specified order, as shown with the CESK-transition \eqref{eval:concat}.
Once all expressions have been evaluated the corresponding application is applied, as shown in \eqref{acontconf:concat}, which results with an expression continuation application to the resulting $\dstring$.
\subsubsection{Type test}
\label{subsubsec:type-test}
Type test expressions evaluate to a boolean literal value, in more than one step.
The evaluation of this kind of expression proceeds by evaluating the target expression, as in CESK-transition \eqref{eval:is}.
When the target expression evaluates to a value $\val$ such that ``$\val $ is $\tt{T}$" holds, the value $true$ is applied to the expression continuation, $\econt$, as shown in \eqref{econtconf:is-true}, otherwise $\false$ is applied to $\econt$, as in \eqref{econtconf:is-false}. 
\subsubsection{Type cast}
\label{subsubsec:type-cast}
Evaluation of type cast expression proceed to evaluation of the target expression to the corresponding value, as shown in \eqref{eval:as}.
When the target expression evaluates to a value $\val$ such that ``$\val $ is $\tt{T}$" holds, the value $\val$ is applied to the expression continuation as shown in \eqref{econtconf:as-true}.
Otherwise, the evaluation of the expression results with an error, as shown in \eqref{econtconf:as-false}.
%%
% Figure showing the CESK-transition function strating from EvalConfgiration for
% static property extraction and assignment, and static invocation
%%
\begin{figure}[Htp]
    \begin{align}
        &\cesktranswhere%
            {\evalconf{\StaticGet{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
            {\contconf{\econt}{\deref{\env^{M}(\membermeta)}}}%
            {\text{where $\membermeta$ is a field and $\membermeta \in \env^{M}$}}
        \label{eval:staticget-var}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\StaticGet{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\contconf{\econt}{\tt{null}}}%
                {\text{where $\membermeta$ is a field, $\membermeta \notin \env^{M}$, $\expressionmeta_{\membermeta} = \tt{null}$, $\env^{M} = \ext{\env^{M}}{\membermeta}{\tt{null}}$}}
        \end{multlined}
        \label{eval:staticget-varnew-null}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\StaticGet{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expressionmeta_{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
                {\text{where $\membermeta$ is a field, $\econt' = \StaticGetK$}}
        \end{multlined}
        \label{eval:staticget-varnew}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\StaticGet{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\execconf{\stmt}{\env_{empty}}{[]}{[]}{\handler}{\cstrace}{\cex}{\econt}{\emptyset}}%
                {\text{where $\membermeta$ is a getter with body $\stmt$}}
        \end{multlined}
        \label{eval:staticget-getter}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\StaticGet{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\contconf{\econt}{\funval{\formals}{\stmt}{\env_{empty}}}}%
                {\text{where $\membermeta$ is a method tear-off with formal parameters $\formals$ and body $\stmt$}}
        \end{multlined}
        \label{eval:staticget-tearoff}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\StaticSet{\membermeta}{\expressionmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
                {\text{where $\econt' = \StaticSetK$}}
        \end{multlined}
        \label{eval:staticset}\\
        &\begin{multlined}
            \cesktranswheresplit%
                {\evalconf{\StaticInvocation{\{\membermeta\}}{\expressionsmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
                {\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont'}}%
                {\text{where $\acont' = \StaticInvA{\formals}{\stmt}{\strace'}{\econt}$, $\strace' = \StaticInvocation{\{\membermeta\}}{\expressionsmeta}::\strace$}}
        \end{multlined}
        \label{eval:staticinvoc}
    \end{align}
	\caption{The CESK-transition function for EvalConfiguration: static variable extraction and assignment, and static method invocation}
	\label{table:static-evalconfigs}
\end{figure}
%%
% Figure showing the CESK-transition function strating from ValuePassingConfiguration for
% static property extraction and assignment, and static invocation
%%
\begin{figure}[Htp]
    \begin{align}
		&\cesktranswhere%
			{\contconf{\StaticGetK}{\val}}%
			{\contconf{\econt}{\val}}%
			{\env^{M} = \ext{\env^{M}}{\membermeta}{\val}}
		\label{econtconf:staticget}\\
		&\cesktranswhere%
			{\contconf{\StaticSetK}{\val}}%
			{\contconf{\econt}{\val}}
			{\text{$\env^{M} = \ext{\env^{M}}{\membermeta}{\val}$ if $\membermeta \notin \env^M$}}
		\label{econtconf:staticset-var-new}\\
		&\cesktranswhere%
			{\contconf{\StaticSetK}{\val}}%
			{\contconf{\econt}{\val}}
			{\text{$\update{\env^{M}(\membermeta)}{\val}$ if $\membermeta \in \env^M$}}
        \label{econtconf:staticset-var}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\contconf{\StaticSetK}{\val}}%
			{\execconf{\stmt}{\env}{[]}{[]}{\handler}{\cstrace}{\cex}{\econt}{\scont}}%
			{\text{$\scont = \ExitSK{\val}$, $\env = \ext{\env_{empty}}{\formal}{\val}$}}
		\end{multlined}
		\label{econtconf:staticset-setter}
    \end{align}
	\caption{The CESK-transition function for ValuePassingConfiguration: static variable extraction and assignment, and static method invocation}
	\label{table:static-evalconfigs}
\end{figure}
%%
% Figure showing the CESK-transition function strating from ApplicationConfiguration.
%%
\begin{figure}[Htp]
    \begin{align}
       &\begin{multlined}
		\cesktrans%
			{\acontconf{\StringConcatenationA}{\vals}}%
			{\contconf{\econt}{\concat(\vals)}}
        \end{multlined}
        \label{acontconf:concat}\\
		&\begin{multlined}
		\cesktranswheresplit*%
			{\acontconf{\StaticInvA{\formals}{\stmt}{\strace}{\econt}}{\val{s}}}%
			{\execconf{\stmt}{\env'}{[]}{[]}{\handler}{\cstrace}{\cex}{\econt}{\scont}}%
			{\parbox{10cm}{where $\scont = \ExitSK{\tt{null}}$,\\ $\env' = \ext{\env_{empty}}{\formals}{\val{s}}$}}
		\end{multlined}
		\label{acontconf:staticinvoc}
    \end{align}
	\caption{The CESK-transition function for ApplicationConfiguration}
	\label{table:static-evalconfigs}
\end{figure}

\subsubsection{Static and library fields}
\label{subsubsec:static-and-library-fields}

In order to remember initialization and assignment of library variables and static variables, we introduce a global environment $\env^{M}$. 
The environment $\env^{M}$ stores bindings for static and library fields to locations for all static and library fields previously accessed or set during the execution of the program.\\
Static and library variables are accessed with $\StaticGet{\membermeta}$.
The member $\membermeta$ can be a static or library field, a getter or a method tear-off.
\begin{itemize}
\item $\membermeta$ is a static or library field\\
Let $\expressionmeta_{\membermeta}$ be $\membermeta$'s initializer expression. 
When $\membermeta$ is accessed for the first time during the program's execution, the evaluation of $\StaticGet{\membermeta}$ proceeds with evaluation of the initializer expression $\expressionmeta_{\membermeta}$.\\
\noindent
When $\expressionmeta$ is $\tt{null}$, the environment is extended with a binding to a fresh location that stores a $\tt{null}$ value for the field $\membermeta$, as shown in \eqref{eval:staticget-varnew-null}.\\
\noindent
When $\expressionmeta$ is an expression, this expression is evaluated as shown in \eqref{eval:staticget-varnew}.
The expression will evaluate to some value $\val$ that will be applied to the corresponding continuations, as shown in \eqref{econtconf:staticget}: the environment is extended with a binding to a fresh location that stores the value $\val$ and the continuation $\econt$ is applied to the value $\val$.\\
\noindent
When there is already a binding for the member $\membermeta$ in the global environment $\env_{M}$, the continuation $\econt$ is applied to the stored value, as shown in \eqref{eval:staticget-var}.
\item $\membermeta$ is a static getter\\
\noindent
When $\membermeta$ is a static getter, the body of the getter is executed, as shown in \eqref{eval:staticget-getter}.
\item $\membermeta$ is a static method tear-off\\
\noindent
When $\membermeta$ is a method with formal parameters $\formals$ and body $\stmt$, a new $\funval{\formals}{\stmt}{\env_{empty}}$ is created and bound to the member in the global environment $\env^{M}$, as shown in \eqref{eval:staticget-tearoff}.
The continuation $\econt$ is applied to this value.
\end{itemize}
\noindent
Static and library variables are set with $\StaticSet{\membermeta}{\expressionmeta}$.
The target member can either be a static or library field, or it can be a static setter. For both cases, the right-hand side expression is evaluated first, as shown in \eqref{eval:staticset}.
\begin{itemize}
\item $\membermeta$ is a static or library field\\
The evaluation proceeds by extending the environment $\env^{M}$, when $\membermeta \notin \env^{M}$, as shown in \eqref{econtconf:staticset-var-new}.\\
\noindent
Otherwise, when $\membermeta \in \env^{M}$, the value stored at location $\env^{M}(\membermeta)$ is modified accordingly, as shown in \eqref{econtconf:staticset-var}.
\item $\membermeta$ is a static setter\\
The evaluation proceeds by executing the statement body of the setter. A statement continuation $\ExitSK{\econt}{\val}$ is added that applies the given expression continuation $\econt$ to the value of the right-hand side expression.
The statement body is executed in an environment that has only the binding from the formal parameter of the static setter to the value of the right-hand side expression, as shown in \eqref{econtconf:staticset-setter}.
\end{itemize}
\noindent
Otherwise, $\membermeta$ is a static or library setter with body $\stmt$ and formal parameter $\formal$.

\subsubsection{Static Invocation}
Static invocation is supported with $\StaticInvocation{\{\membermeta\}}{\expressionsmeta}$ where $\membermeta$ is a function with statement body $\stmt$ and formal parameters $\formals$.
The evaluation of a static invocation proceeds by evaluating the arguments of the call, as shown in \eqref{eval:staticinvoc}.\\
After the evaluation of the actual arguments for the invocation, the corresponding application is applied to the resulting list of values, as shown in \eqref{acontconf:staticinvoc}.
In \eqref{acontconf:staticinvoc}, we apply the application continuation by creating a new environment for the execution of the body of the method by binding its formal parameters to the locations of the values for the actual arguments.
A statement continuation, $\ExitSK{\econt}{\tt{null}}$ is added as next statement continuation to ensure that the execution of the body of the method returns correctly, when a return statement is not executed after the execution of the last statement of the body.
\begin{figure}[Htp]
    \begin{align}
		&\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\PropertyGet{\expressionmeta}{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
			{\text{where $\econt' = \PropertyGetK$}}
		\end{multlined}\\
		&\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\DirectPropertyGet{\expressionmeta}{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
			{\text{where $\econt' = \DPropertyGetK$}}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\PropertySet{\expressionmeta_0}{\idmeta}{\expressionmeta_1}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta_0}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
			{\text{where $\econt' = \PropertySetK$}}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\DirectPropertySet{\expressionmeta_0}{\membermeta}{\expressionmeta_1}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
			{\text{where $\econt' = \DirectPropertySetK$}}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\SuperPropertyGet{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\contconf{\econt}{\funval{\formals}{\stmt}{\env'}}}%
            {\parbox{10cm}{where $\env' = \ext{\env_{empty}}{\this}{\deref{(\env(\this))}}$,\\ $\membermeta = \superclass{\deref{\env(\this)}}.lookup(\idmeta)$,\\ $\membermeta$ is a method tear-off with formal parameters $\formals$, and body $\stmt$}}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\SuperPropertyGet{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}%
            {\parbox{10cm}{where $\env' = \ext{\env_{empty}}{\this}{\deref{(\env(\this))}}$,\\ $\scont = \emptyset$, $\membermeta = \superclass{\deref{\env(\this)}}.lookup(\idmeta)$,\\ $\membermeta$ is a getter method with body $\stmt$}}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\SuperPropertyGet{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\contconf{\econt}{M(\deref{(\env(\this))})}}%
            {\text{where $\membermeta = \superclass{\deref{\env(\this)}}.lookup(\idmeta)$, $\membermeta$ is a implicit field getter}}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\SuperPropertySet{\idmeta}{\expressionmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
            {\text{where $\econt' = \SuperPropertySetK$}}
        \end{multlined}
    \end{align}
	\caption{The CESK-transition function for EvalConfiguration: instance property extraction and assignment}
	\label{figure:instance-property-evalconfigs}
\end{figure}

\subsubsection{Property extraction}
\label{subsubsec:property-extraction}
Kernel allows access of a member as a property, which can be either getter access, which executes the getter, or method extraction, which converts a method into a closure, also known as tear-off.
\noindent
After the evaluation of the receiver expression to a value $\val$, the property $\idmeta$ is looked up in methods, getters and implicit getters for the value $\val$.
Let $\membermeta$ be the result of such lookup.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\textrm{if M is a method with body }\stmt\textrm{ and formals }\formals :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\PropertyGetK}{\val}}{
		\contconf{\econt}{\funval{\formals}{\stmt}{\env}}}\\
	\textrm{with}\\
	\hspace{3mm}
	\env = \ext{\env_{empty}}{\mathbf{this}}{\val}\\[2mm]

	\textrm{if M is getter with statement body }\stmt :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\PropertyGetK}{\val}}{
		\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
		}\\
	\textrm{with}\\
	\hspace{3mm}
	\env = \ext{\env_{empty}}{\mathbf{this}}{\val}\\
	\hspace{3mm}
	\scont = \emptyset\\[2mm]

	\textrm{if M is an implicit getter for field }\idmeta :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\PropertyGetK}{\val}}{
		\contconf{\econt}{\textrm{R}(\val)}}
  \end{array}
\]
%If the lookup fails, noSuchMethod is created/invoked accordingly (TBD)

\subsubsection{Direct property extraction}
\label{subsubsec:direct-property-extraction}
In Kernel a property can be accessed without lookup, by direct reference to the $AST$ node of said property.
This implies that the lookup step above is bypassed.

\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\textrm{if }\membermeta \textrm{ is a method with body }\stmt\textrm{ and formals }\formals :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\DPropertyGetK}{\val}}{
		\contconf{\econt}{\funval{\formals}{\stmt}{\env}}}\\
	\textrm{with}\\
	\hspace{3mm}
	\env = \ext{\env_{empty}}{\mathbf{this}}{\val}\\[2mm]

	\textrm{if }\membermeta \textrm{ is getter with statement body }\stmt :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\DPropertyGetK}{\val}}{
		\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
		\\
	\textrm{with}\\
	\hspace{3mm}
	\env = \ext{\env_{empty}}{\mathbf{this}}{\val}\\
	\hspace{3mm}
	\scont = \emptyset\\[2mm]

	\textrm{if }\membermeta \textrm{ is a field } :\\
	\hspace{2mm}\cesktrans{
		\contconf{\DPropertyGetK}{\val}}{
		\contconf{\econt}{\deref{\val[\membermeta]}}}\\
  \end{array}
\]
\subsubsection{Property assignment}
\label{subsubsec:property-assignment}
An assignment changes the value stored at the location of the provided property name.
A property assignment in Kernel can be done by executing a setter or accessing an instance variable and setting its value.
\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\PropertySetK}{\val_0}}{
		\evalconf{\expressionmeta_1}{\env}{\strace}{\cstrace}{\cex}{\econt'}}\\
	\econt' = \PropertySetVK
  \end{array}
\]
\noindent
After the evaluation of the receiver expression to a value $\val_0$ and the argument to value $\val_1$, the property $\idmeta$ is looked up in setters and implicit setters for the value $\val_0$.
Let $\membermeta$ be the result of such lookup.
\[
  \begin{array}{lcl}
	\textrm{if \membermeta is setter with statement body }\stmt \textrm{ and formal }\formal :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\PropertySetVK}{\val_1}}{
		\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}\\
	\textrm{with}\\
	\hspace{3mm}
	\env = \ext{\env_{empty}}{\mathbf{this} :: \formal :: []}{\val_0 :: \val_1 :: []}\\
	\hspace{3mm}
	\scont = \emptyset\\[2mm]

	\textrm{if \membermeta is an implicit setter for field }\idmeta :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\PropertySetK}{\val}}{
		\contconf{\econt}{\textrm{R}(\val_0, \val_1)}}
  \end{array}
\]

\subsubsection{Direct property assignment}
\label{subsubsec:direct-property-assignment}
In Kernel a property can be set without lookup, by direct reference to the $AST$ node of the property.
This implies that the lookup step above is bypassed.

\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\cesktrans{
		\contconf{\DirectPropertySetK}{\val_0}}{
		\evalconf{\expressionmeta_1}{\env}{\strace}{\cstrace}{\cex}{\econt'}}\\
	\textrm{with}\\
	\hspace{3mm}
	\econt' = \DPropertySetVK\\[2mm]

	\textrm{if }\membermeta \textrm{ is setter with statement body }\stmt \textrm{ and formal }\formal :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\DPropertySetVK}{\val_1}}{
		\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}\\
	\textrm{with}\\
	\hspace{3mm}
	\env = \ext{\env_{empty}}{\mathbf{this} :: \formal :: []}{\val_0 :: \val_1 :: []}\\
	\hspace{3mm}
	\scont = \emptyset\\[2mm]

	\textrm{if }\membermeta \textrm{ is a field } :\\
	\hspace{2mm}
	\cesktrans{
		\contconf{\DPropertySetVK}{\val_1}}{
		\contconf{\econt}{\update{\val_0[\membermeta]}{\val_1}}}
  \end{array}
\]

\subsubsection{Super property get}
\label{subsubsec:super-property-get}
%\newcommand{\SuperPropertyGet}[1]{\tt{super}.#1}
Kernel allows access of a superclass member as a property, which can be either getter access, which executes the getter, or method extraction, which converts a method into a closure.
\noindent
Accessing a superclass member is accessed with the expression $\SuperPropertyGet{\idmeta}$ evaluated with the corresponding components: $\env$, $\strace$, $\handler$, $\cstrace$, $\cex$, $\econt$.
Let $\val = \deref{(\env(\this))}$, $C = \superclass{\val}$ and $M$ the result of looking up $\idmeta$ in $C$.\\

\subsubsection{Super property assignment}
\label{subsubsec:super-property-assignemnt}
Kernel supports assignment of a super member with the expression $\SuperPropertySet{\idmeta}{\expressionmeta}$.
Let $\val = \deref{(\env(\this))}$, $C = \superclass{\val}$ and $M$ the result of looking up $\idmeta$ in $C$.\\
If $\membermeta$ is a setter method with body $\stmt$ and formal $\formal$:
\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\SuperPropertySetK}{\val}}{
		\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}\\
  \end{array}
\]
with $\env' =  \ext{\env_{empty}}{\this :: \formal :: []}{\deref{(\env(\this))} :: \val :: []}, \hspace{2mm}\scont = \emptyset$.\\
If $\membermeta$ is a implicit field setter:
\[
  \begin{array}{lcl}
	\hspace{2mm}
	\cesktrans{
		\contconf{\SuperPropertySetK}{\val}}{
		\contconf{\econt}{M(\deref{(\env(\this))}, \val)}}
  \end{array}
\]


\begin{figure}[Htp]
    \begin{align}
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\InstanceMethodInvocation{\expressionmeta}{\idmeta}{\expressionsmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
			{\econt' = \InstanceMethodK}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\DInstanceMethodInvocation{\expressionmeta}{\membermeta}{\expressionsmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}}%
			{\econt' = \DInstanceMethodK}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\SuperMethodInvocation{\idmeta}{\expressionsmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}}%
			{\evallistconf{\expressionsmeta}{\env}{\strace}{\cstrace}{\cex}{\acont}}%
			{\acont = \SuperMethodA}
        \end{multlined}\\
        &\begin{multlined}
		\cesktranswheresplit%
			{\evalconf{\textbf{new Q}(\exprs)}{\env}{st}{cex}{cst}{\econt}}%
			{\evallistconf{\exprs}{\env}{st}{cex}{cst}{\acont'}}%
			{\acont' = \ConstructorA{Q}{\econt}}
        \end{multlined}
    \end{align}
	\caption{The CESK-transition function for EvalConfiguration: instance method and constructor invocation}
	\label{figure:instance-method-evalconfigs}
\end{figure}
\subsubsection{Instance method invocation}
\label{subsubsec:instance-method-invoc}
Method invocation is supported with $\InstanceMethodInvocation{\expressionmeta}{\idmeta}{\expressionsmeta}$.

\noindent
The arguments $\expressionsmeta$ are evaluated after the evaluation of the receiver.
\newcommand{\InstanceMethodInvocationArgsApp}{\mathrm{InstanceMethodA(\idmeta,\,\val,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}}
\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\InstanceMethodK}{\val}}{
		\evallistconf{\expressionsmeta}{\env}{\strace}{\cstrace}{\cex}{\acont'}}
	\\
	\textrm{with } \acont' = \InstanceMethodInvocationArgsApp
  \end{array}
\]
\noindent
After the evaluation of the receiver expression to a value $\val$ and the argument expressions to $\vals$, the instance method $\idmeta$ is looked up in methods for the value $\val$.
Let $\membermeta$ be the result of such lookup.

\noindent
Let $\membermeta$ be a method with statement body $\stmt$ and formal parameters $\formals$:
\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\InstanceMethodInvocationArgsApp}{\val{s}}}{
		\execconf{\stmt}{\env}{[]}{[]}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
	\\[2mm]
	\cesktrans{
		\scontconf{\ExitSK{\val}}{\env}}{
		\contconf{\econt}{\val}}
  \end{array}
\]
with $\scont = \ExitSK{\tt{null}}, \env = \ext{\env_{empty}}{\this :: \formals}{\val :: \val{s}}$.\\[2mm]

\noindent
When a $\tt{return}$ statement is missing in the statement body $\stmt$ of the instance method $\membermeta$, the statement continuation $\ExitSK{\val}$ ensures that the execution will proceed to the corresponding expression continuation, in this case with $\val = \tt{null}$.

\subsubsection{Direct instance method invocation}
\label{subsubsec:direct-instance-method-invoc}
Direct method invocation allows invocation of instance method by providing directly the member method to be invoked and bypass the lookup step described above.
Let $\membermeta$ be the target method, $\stmt$ the statement body and $\formals$ the corresponding formal parameters.

\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\DInstanceMethodK}{\val}}{
		\evallistconf{\expressionsmeta}{\env}{\strace}{\cstrace}{\cex}{\acont'}}
	\\[2mm]

	\cesktrans{
		\contconf{\DInstanceMethodA}{\val{s}}}{
		\execconf{\stmt}{\env}{[]}{[]}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
  \end{array}
\]
with
\[
\begin{array}{l}
	\acont' = \DInstanceMethodA,\\
	\scont = \ExitSK{\tt{null}},\\
	\env = \ext{\env_{empty}}{\this :: \formals}{\val :: \val{s}}
\end{array}
\]

\noindent
Similarly to \ref{subsubsec:instance-method-invoc}, $\ExitSK{\val}$ is added as next statement continuation.

\subsubsection{Super method invocation}
\label{subsubsec:super-method-invocation}
Super method invocation is supported with $\SuperMethodInvocation{\idmeta}{\expressionsmeta}$ and the transition step is as follows:

After the evaluation of the expressions $\expressionsmeta$ to values $\val{s}$ for the super method invocation, the method $\idmeta$ is looked up.
Let $\val = \deref{(\env(\this))}$, $C = \superclass{\val}$ and $M$ the result of looking up $\idmeta$ in $C$.
Let $\stmt$ be the statement body and $\formals$ the formal parameters for $\membermeta$ below:
\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\SuperMethodA}{\val{s}}}{
		\execconf{\stmt}{\env'}{[]}{[]}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
	\\[2mm]
	\textrm{with }\\
	\hspace{3mm}\scont = \ExitSK{\tt{null}},\\
	\hspace{3mm}\env' = \ext{\env_{empty}}{\this :: \formals}{\deref{(\env(\this))} :: \val{s}}\\[2mm]
  \end{array}
\]
Similarly to \ref{subsubsec:instance-method-invoc}, $\ExitSK{\val}$ is added as next statement continuation.

\subsubsection{This}
For the evaluation $\this$ expression we add a special variable declaration, $\this$.
In the body of instance methods or constructors, there is a binding in the corresponding environment from $\this$ variable declaration to a label that stores the corresponding object.
Evaluation of $\this$ expression resolves to the value in one step.
\subsection{Statement execution}
\label{subsec:stmt-exectution}
\newcommand{\execcesktrans}[3]{&\cesktrans{#1}{#2}\,\hspace{2mm}#3\hspace{6mm}\\[2mm]}
%
\newcommand{\ExpressionK}[2]{\mathrm{ExpressionK}({#1},\,{#2})}
%
\begin{figure}[Htp]
	$
	\begin{array}{cl}
		\execcesktrans
			{\execconf{\VarDeclaration{\varmeta}{\expr}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}
			{\\&\econt' = \VarDeclK{\env}{\varmeta}{\scont}}

		\execcesktrans
			{\execconf{\EmptyStatement}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\scontconf{\scont}{\env}}
			{}

		\execcesktrans
			{\execconf{\ExpressionStatement{\expressionmeta}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}
			{\\&\econt' = \ExpressionK{\scont}{\env}}

		\execcesktrans
			{\execconf{\Block{\stmt_1}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{}
			{\\&\hspace{4mm}\execconf{\stmt_1}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}
			\\&\scont' = \BlockSK{\stmt*}{\env}}

		\execcesktrans
			{\execconf{\IfStatement{\expr}{\stmti{1}}{\stmti{2}}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}
			{\\&\econt' = \IfCondK{\stmti{1}}{\stmti{2}}}

		\execcesktrans
			{\execconf{\ReturnStatement{\expr}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}
			{}

		\execcesktrans
			{\execconf{\ReturnStatement{}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\contconf{\econt}{\textbf{null}}}
			{}

		\execcesktrans
			{\execconf{\DoStatement{\statementmeta}{\expressionmeta}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\execconf{\statementmeta}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}}
			{\\&\scont' = \whilecondk\hspace{2cm}}

		\execcesktrans
			{\execconf{\WhileStatement{\expr}{\stmt}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}
			{\\&\econt', \scont' = \whilecondk}

		\execcesktrans
			{\execconf{\ForStatement{\varmeta{s}}{\expressionmeta}{\exprs}{\statementmeta}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evallistconf{\exprs'}{\env}{\strace}{\cex}{\cstrace}{\acont}}
			{\\&\acont = \ForInitA
			\\&\exprs' = \text{initializer expressions for the list of variable declarations }\varmeta{s}}

		\execcesktrans
			{\execconf{\LabeledStatement{L}{\stmt_{L}}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{}
			{\\&\hspace{4mm}\execconf{\stmt_{L}}{\env}{\lbl :: \lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
			\\&\lbl = \mathrm{Label}(L, \bcont), \bcont = \mathrm{Break}(\env, \scont)}

		\execcesktrans
			{\execconf{\SwitchStatement{\expr}{\scases}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}}
			{\\&\econt' = \SwitchK{\scases}{\clbls}}

		\execcesktrans
			{\execconf{\TryCatch{\stmt}{cs}}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}}
			{}
			{\\&\hspace{4mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler'}{\cex}{\cstrace}{\econt}{\scont}
			\\&\handler' = \CatchH{cs}}

		\execcesktrans
			{\execconf{\BreakStatement{L}}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}}
			{\breakconf{\bcont}}
			{\\&\lbl = Label(L', \bcont) \in \lbls \textrm{ with } L' == \mathbf{L}}

		\execcesktrans
			{\execconf{\ContinueSwitchStatement{\stmt}}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}}
			{\switchconf{\switchcont}}
			{\\&\clbl = \continuel{\stmt'}{\switchcont} \in \clbls \textrm{ with } \stmt' == \stmt}

		\execcesktrans
			{\execconf{fun(\formals) \stmt_{body}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}}
			{}
			{\\&\hspace{4mm}\contconf{\econt}{\funval{\stmt_{body}}{\formals}{\env'}}
			\\&\env' = \ext{\env}{fun}{\funval{\stmt_{body}}{\formals}{\env'}}}
	\end{array}
	$
	\caption{The CESK-transition function for statements}
	\label{figure:exec}
	\end{figure}

\subsubsection{Variable Declaration}
Variable declaration extend the corresponding environment with a new binding.
The corresponding initializer expression is first evaluated to a value $v$.

\noindent
Let $\econt' = \VarDeclK{\env}{\varmeta}{\scont}$ below:
\[
  \begin{array}{lcl}
	\cesktrans{
		\contconf{\econt'}{\val}}{
		\scontconf{\scont}{\ext{\env}{\varmeta}{\val}}}
  \end{array}
\]

\subsubsection{Empty statement}
\label{subsubsec:emtpy-stmt}


\subsubsection{Expression statement}
\label{expression-stmt}

\subsubsection{Block statements}
\[
  \begin{array}{lcl}
	\cesktrans{
		\scontconf{\BlockSK{\stmt :: \stmts}{\env}}{\env'}}{
		\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}}
		\\[2mm]

	\cesktrans{
		\scontconf{\BlockSK{[]}{\env}}{ \_ }}{
		\scontconf{\scont}{\env}}
		\\[2mm]
  \end{array}
\]
\noindent
with $\scont' = \BlockSK{\stmts}{\env}$.

\subsubsection{If statement}

Let $\econt' = \IfCondK{\stmti{1}}{\stmti{2}}$ below:
\[
  \begin{array}{lcl}
	\contconf{\econt'}{\true}
	& \Rightarrow &
	\execconf{\stmti{1}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\[2mm]

	\contconf{\econt'}{\false}
	& \Rightarrow &
	\execconf{\stmti{2}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
  \end{array}
\]

\subsubsection{Return statement}

\subsubsection{Loops}
Let $\econt', \scont' = \whilecondk$ below:
\[
  \begin{array}{lcl}
	\contconf{\econt'}{\false}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]

	\contconf{\econt'}{\true}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}\\[2mm]

	\scontconf{\scont'}{\_}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
  \end{array}
\]
Loops \textbf{do while}, \textbf{for in}, for can be desugared to while loops with transformations performed before interpreting the program.

The execution of \textbf{do while} loops proceeds as shown in Figure~\ref{figure:exec}.
The execution of \textbf{for} loops proceeds as shown in Figure~\ref{figure:exec}.
\[
 \begin{array}{l}
	\acontconf{\ForInitA}{\vals}
	\Rightarrow
	\evalconf{\expressionmeta}{\env'}{\strace}{\cstrace}{\cex}{\econt'} \\
	\env' = \extend(\env, \varmeta{s}, \vals) \\
	\econt' = \ForCondK
	\\[2mm]

	\contconf{\ForCondK}{\tt{false}}
	\Rightarrow
	\scontconf{\scont}{\env}
	\\[2mm]

	\contconf{\ForCondK}{\tt{true}}
	\Rightarrow \\
	\execconf{\scont}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'} \\
	\scont' = \ForSK
	\\[2mm]

	\scontconf{\ForSK}{\_}
	\Rightarrow
	\evallistconf{\exprs}{\env_{new}}{st}{cex}{cst}{\acont} \\
	\acont = \ForUpdatesA{\env_{new}} \\
	\env_{new} = \extend(\env, \varmeta{s}, \vals), \vals = \{\val_i \mid \deref(\env'(\varmeta_i))\}
	\\[2mm]

	\acontconf{\ForUpdatesA{\env'}}{\_}
	\Rightarrow
	\evalconf{\expressionmeta}{\env'}{\strace}{\cstrace}{\cex}{\econt'}\\
	\econt' = \ForCondK
 \end{array}
\]

In Kernel, \textbf{for in} loops, will be desugared into while loops and their execution will proceed as the \textbf{while} loop rule shown in Figure~\ref{figure:exec}.
\subsection{Labels}

Kernel supports labelling statements, \textbf{L: $\stmt_{L}$}, and breaking to L, \textbf{break L}, which completes the execution of the labelled statement and proceeds to executing the rest of the program.
To support breaking to a label, we add a labels component, $\lbls$, to statement configurations.
$\lbls$ represents a list of pairs mapping a labelled statement, \textbf{L: $\stmt_L$}, to a break statement continuation, $\bcont$.
Executing a labelled statement inserts a new break label, $\lbl$ in the list of labels $\lbls$.

\subsection{Switch}
Kernel supports dispatching control among a number of cases with \textbf{switch} statements.
The target expression $\expr$ is evaluated and matched against the different case clauses of the switch statement.

\noindent
Case clauses can have multiple constant expressions and there is no implicit fall-through between cases.
Kernel supports continuing to execution of a preceding case clause with continue statements where the target of the continue statement is a preceding case clause, e.g, continue C with C = case $\expri{1..i}$: $\stmt$.
To support continue, we add an optional $\clbls$ list, similar to the label list, which is set in a switch statement and unset otherwise.

\noindent
If there is a matching case clause, its statement is executed with a new statement continuation that will throw when reached.
The new statement continuation is necessary because implicit fall-through is not supported and an explicit break of the flow is required (with either of \textbf{continue, break, return, throw}).

\[
  \begin{array}{lcl}
	\contconf{\SwitchK{\scase :: \scases}{\clbls}}{\val}
	\Rightarrow \hspace{30mm}\\
	\hspace{20mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\ExitSK{\tt{null}}}
  \end{array}
\]
with:
\[
	\scase = \textbf{case } \expri{1}, \dots, \expri{i} \textbf{ : } \stmt \textrm{ and } \scase \textrm{ is a matching \textbf{case} clause}
\]
A case clause is matching if is \textbf{default} or there is at least one of the constant expressions in the case clause identical to the target value of the switch.

\noindent
If a non-matching \textbf{case} clause, $\scase$, is the target of a continue statement, it installs a new continue label, in order to support execution of its statement with the appropriate configuration.

\[
  \begin{array}{lcl}
	\contconf{\SwitchK{\scase :: \scases}{\clbls}}{\val}
	\Rightarrow \hspace{30mm}\\
	\hspace{20mm}\contconf{\SwitchK{\scases}{\clbl :: \clbls}}{\val}
  \end{array}
\]
with:
\[
  \begin{array}{l}
	\clbl = \continuel{\scase}{\switchcont},\\
	\switchcont = \ContinueK
  \end{array}
\]
\noindent
Otherwise, the execution continues as follows:
\[
  \begin{array}{lcl}
    \contconf{\SwitchK{\scase :: \scases}{\clbls}}{\val}
	\Rightarrow \hspace{30mm}\\
	\hspace{20mm}\contconf{\SwitchK{\scases}{\clbls}}{\val}\\[2mm]

	\contconf{\SwitchK{[]}{\clbls}}{\val}
	\Rightarrow
	\scontconf{\scont}{\env}
  \end{array}
\]

\subsection{Exceptions}

Kernel supports structured exception handling with \textbf{try/catch} and \textbf{try/finally} statements.
Exceptions are thrown with \textbf{throw} and \textbf{rethrow} expressions.
To support throwing exceptions, we add a handler, $\handler$, and a stacktrace, $\strace$, component to expression configurations (and correspondingly, to statement configurations).
To support \textbf{rethrow}, we add an optional current error, $\cex$, and current stack trace, $\cstrace$, which are set when inside a catch block and unset otherwise.

\[
  \begin{array}{lcl}
	\contconf{\ThrowH{\strace}{\handler}}{\val}
	& \Rightarrow &
	\throwconf{\handler}{\val}{\strace}\\[2mm]

  \end{array}
\]

\noindent
\textbf{try/catch} handlers contain a list of on-catch handlers, environment, break labels, continue switch labels, exception handler, stacktrace, return continuation, and statement continuation.
The handlers are tried in order to see if they match against the type of the exception.
If none match, the exception is rethrown.

\noindent
Let $\econt' = \CatchH{(\textbf{on T catch (e, s) }\stmt) :: cs}$ be a catch continuation containing a non-empty list of on-catch handlers:
\[
  \begin{array}{lcll}
	\throwconf{\econt'}{\val}{\strace'}
	& \Rightarrow &
	\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{inr(\val)}{inr(\strace')}{\econt}{\scont}
	&\textrm{ if V is T}\\[1mm]

	&&\textrm{with } \env' = \extend(\env, e :: s :: [], \val :: \strace' :: [])\\[2mm]

	\throwconf{\econt'}{\val}{\strace'}
	& \Rightarrow &
	\throwconf{\CatchH{cs}}{\val}{\strace'}	&\textrm{ otherwise}\\[2mm]
	&&\textrm{with } \env' = \extend(\env, e :: s :: [], \val :: \strace' :: [])
  \end{array}
\]
\noindent
When a catch handler with no on-catch handlers is reached, the exception is rethrown.
\[
  \begin{array}{lcll}
	\throwconf{\CatchH{[]}}{\val}{\strace'}
	& \Rightarrow &
	\throwconf{\handler}{\val}{\strace'}\hspace{20mm}
  \end{array}
\]
\noindent
\textbf{try/finally} handlers contain a statement, environment, break labels, continue switch labels, exception handler, stacktrace, and return continuation.
Note that they do not contain a statement continuation because when control falls off the end of the finally statement the exception is rethrown.
The statement is unconditionally executed:

\[
  \begin{array}{lcl}
	\throwconf{\FinallyK{\stmt}}{\val}{\strace'}
	\Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{inl()}{inl()}{\econt}{\RethrowSK{\val}{\strace'}{\handler}}\hspace{20mm}\\[2mm]

	\scontconf{\RethrowSK{\val}{\strace}{\handler}}{\_}
	\Rightarrow \throwconf{\handler}{\val}{\strace}

  \end{array}
\]
\noindent
\textbf{try/catch} statements execute their body with a new handler.

\noindent
\textbf{try/finally} statements execute their body with a new handler and additionally install new break and continue switch labels, a new return continuation, and a new statement continuation:

\[
  \begin{array}{lcl}
	\execconf{\TryFinally{\stmti{0}}{\stmti{1}}}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}
	\Rightarrow\\
	\execconf{\stmti{0}}{\env}{\lbls'}{\clbls'}{\handler'}{\cex}{\cstrace}{\econt'}{\scont'}
	  \end{array}
\]
where:

\[
  \begin{array}{lcl}
	\handler' = \FinallyK{\stmti{0}}\hspace{50mm}\\[2mm]

	\econt' = \FinallyReturnK{\stmti{1}}\\[2mm]

	\scont' = \FinallySK{\stmti{1}}\\[2mm]

	\lbls' = \lbrace \mathrm{Label}(L, \bcont') \mid \mathrm{Label}(L, \bcont) \in \lbls\rbrace \\
	\hspace{10mm}\textrm{where } \bcont = \FinallyBreak{\stmti{1}}{\bcont}\\[2mm]
	\clbls' =  \lbrace \continuel{C}{\switchcont'} \mid  \continuel{C}{\switchcont} \in \clbls\rbrace\\
	\hspace{10mm}\textrm{where } \switchcont' = \FinallyContinue{\stmti{1}}{\switchcont}

  \end{array}
\]
\subsection{Break}
\textbf{break L} statements break from an enclosing label \textbf{L} and execute the break continuation corresponding to the label in the list of labels $\lbls$.

Let $\lbl = Label(L', \bcont) \in \lbls \textrm{ with } L' == \mathbf{L}$ below:
\[
  \begin{array}{lcl}
	\breakconf{\Break{\env}{\scont}}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]

	\breakconf{\FinallyBreak{\stmt}{\bcont}}
	& \Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\mathrm{BreakSK}(\bcont)}\\[2mm]

	\scontconf{\mathrm{BreakSK}(\bcont)}{\env}
	& \Rightarrow &
	\breakconf{\bcont}

  \end{array}
\]

\subsection{Continue}
\textbf{continue L} statements continue to executing the statement of a preceding case clause, labelled with \textbf{L} and execute the continue continuation corresponding to the label in the list of labels $\clbls$.

Let $\clbl = \continuel{L'}{\switchcont} \in \clbls \textrm{ with } L' == \mathbf{L}$ below:
\[
  \begin{array}{lcl}
	\switchconf{\ContinueK}
	& \Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}\\[2mm]

	\switchconf{\FinallyContinue{\stmt}{\switchcont}}
	& \Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\mathrm{SwitchContinueSK}(\switchcont)}\\[2mm]

	\scontconf{\mathrm{SwitchContinueSK}(\switchcont)}{\env}
	& \Rightarrow \\
	\hspace{10mm}\switchconf{\switchcont}
  \end{array}
\]
\subsection{Closures}
\subsubsection{Function expressions}

Kernel supports encapsulating an executable unit of code with function expressions.
To support function expressions we introduce $fv = \funval{\stmt_{body}}{\formals}{\env} \in \dfunval$ as a value that has the function statement body, $\stmt_{body} \in \dstmt$, its list of formal parameters, $\formals \in \dformals$, and the environment, $\env \in \denv$ in scope of the function expression.
This ensures that there are no free variables in the body of $fv$.
$fv \in \dfunval$ has only one method, $call$.

\subsubsection{Function declaration}
Kernel supports local function declaration, where a final variable stores a function value.
Let $F$ be a function with a body $\stmt_{body}$ and a list of formal parameters, $\formals$, and let $fun \in \dvardecl$ be the corresponding final variable declaration.

\subsection{New instance creation}
\newcommand{\Initializer}[1]{\mathrm{Initializer}(#1)}
\newcommand{\SuperInitializer}[2]{\mathrm{SuperInitializer}(#1,\,#2)}
\newcommand{\RedirectingInitializer}[2]{\mathrm{RedirectingInitializer}(#1,\,#2)}

The expression \textbf{new} invokes a constructor to produce a new instance.
The target constructor \textbf{Q} has a list of formal parameters, $\formals$, a list of initializers, $Izs$, and a statement body, $\stmt_{body}$.
The invocation of a constructor \textbf{Q} with \textbf{new Q}($\exprs$) proceeds as follows:
\[
  \begin{array}{lcl}
	\acontconf{\ConstructorA{\textbf{Q}}{\econt}}{\val{s}}
	& \Rightarrow &
	\contconf{\InitK{Q}{\env}{\scont}}{!\loc}
  \end{array}
\]
\noindent
where $\loc$ is the location of the newly allocated instance, $\val \in \dobjval$, in the store.
The value $\val$ stores the class of the object and the fields, as a list of freshly allocated locations for each field of the new instance.
\[
  \begin{array}{l}
	\deref{\loc} = \objval \in \dobjval, fields \in \mlist{\dlocation}\\
	\env' = \extend(\env_{empty}, \formals, \val{s})\\
	\scont = \NewSK{\econt}{\loc} \\[2mm]

	\scontconf{\NewSK{\econt}{\loc}}{\env}
	\Rightarrow
	\contconf{\econt}{\deref{\loc}}
  \end{array}
\]

\noindent
Let $li = last(Izs)$ be the last initializer in the list of initializers, $Izs$, of constructor \textbf{Q}.

\noindent
When $li$ is a redirecting initializer to target constructor \textbf{G}, then execution of constructor \textbf{Q} proceeds immediately with execution of its initializer list, $Izs$.
\[
  \begin{array}{lcl}
	\contconf{\InitK{Q}{\env}{\scont}}{\val}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\
	&&
	\textrm{if } Izs = RedirectingI(G, \exprs) :: []\\
	\textrm{where:}\\
	\acont = \RedirectingA{G}{\loc}{\scont}\\
	\deref{\loc} = \val
	\\[2mm]

	\contconf{\InitK{Q}{\env}{\scont}}{\val}
	& \Rightarrow &
	\evalconf{\expr}{\env}{st}{cex}{cst}{\econt'}\\
	&&
	\textrm{otherwise}\\
	\textrm{where:}\\

	fi = Initializer(\expr) \textrm{, first initializer in }Izs\\
	\econt' = \InitializerK{Izs}{\loc}{\env}{\scont}\\
	\deref{\loc} = \val\\[2mm]

	\acontconf{\RedirectingA{G}{\loc}{\scont}}{\val{s}}
	& \Rightarrow &
	\contconf{\InitK{G}{\env'}{\scont}}{\deref{\loc}}\\[2mm]
	\textrm{where:}\\
	\env' = \extend(\env_{empty}, \formals, \val{s})
  \end{array}
\]
\noindent
Otherwise, \textbf{Q} is a non-redirecting generative constructor, and execution of \textbf{Q} proceeds with evaluation of field initializers in the immediately enclosing class.
\noindent
Let \textbf{Q} be a constructor with non empty initializer list, $Izs$ and a constructor body $\stmt_{body}$.
\[
  \begin{array}{lcl}
	\contconf{\InitK{Q}{\env}{\scont}}{\val}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\[2mm]

	\textrm{where:}\\
	\env' = \ext{\env}{\mathbf{this}}{\deref{\loc}}
	&&
	\exprs = \textrm{initializer expressions for instance fields}\\
	\deref{\loc} = \val
	&&
	\acont = \FieldsA{\env}{Izs}{\loc}{\scont'}\\
	&&
	\scont' = \BodySK{\stmt_{body}}{\env'}{\scont}
  \end{array}
\]
\noindent
To further initialize the new instance, the body of the constructor will be executed.
In Kernel the body of a constructor is executed after the execution of the initializer list and its super constructor.
\noindent
To support this, we add a new statement continuation, $BodySK$, that has the constructor body statement, the environment, the error handlers and stacktraces, and the next statement continuation.
\[
  \begin{array}{lcl}
	\scontconf{\BodySK{\stmt}{\env}{\scont}}{\_}
	& \Rightarrow &
	\execconf{\stmt}{\env}{[]}{[]}{\handler}{\cex}{\cstrace}{\econt}{\scont}
  \end{array}
\]

\noindent
After the evaluation of the initializer expressions, the locations for each field in the object value are updated accordingly.
An update of field $f_i$, stored at location $\loc' = (\deref{\loc})[f_i]$ with value $\val_i$ is expressed as $\update{(\deref{\loc})[f_i]}{\val_{i}}$, so the following holds $\deref{\loc'} = \deref{\deref{\loc[f_i]}} = \val_{i}$ after the update.

\noindent
Let $Fs$ be the list of fields for value $\deref{\loc}$ for the class immediately enclosing the current constructor below.

If the initializer list is empty, $Izs = []$, the next statement continuation is executed.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\FieldsA{\env}{Izs}{\loc}{\scont}}{\val{s}}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]
	&&\textrm{with }\deref{\deref\loc[f_i]} = \val_{i}, \forall f_i \in Fs, \forall \val_i \in \val{s}
  \end{array}
\]
\noindent
In Kernel, a super initializer or a redirecting initializer, when present, will appear last in the initializer list.\\
If the initializer list contains at least two initializers, $Izs = Ininitalizer(E) :: Izs', Izs' \neq []$, we can assume that the next initializer to execute is a local or a field initializer.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\FieldsA{\env}{Izs}{\loc}{\scont}}{\val{s}}
	& \Rightarrow &
	\evalconf{\expr}{\env}{st}{cex}{cst}{\econt'}\\[2mm]
	&&\textrm{with }\deref{\deref{\loc[f_i]}} = \val_{i}, \forall f_i \in Fs, \forall \val_i \in \val{s}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \InitK{Izs}{\loc}{\env}
  \end{array}
\]

\noindent
Otherwise, there is only one initializer to execute in the initializer list, $li$: \\
\begin{itemize}

\item When $li$ is field or local initializer, the transition is identical to the rule for non empty and non singleton initializer lists, described above.\\
\item When the last initializer is a redirecting constructor, i.e. $li = RedirectingI(G, \exprs)$, the transition is as follows:
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\FieldsA{\env}{li::[]}{\loc}{\scont}}{\val{s}}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\
	&&\textrm{with }\deref{\deref{\loc[f_i]}} = \val_{i}, \forall f_i \in Fs, \forall \val_i \in \val{s}\\
	\textrm{where:}\\
	\acont = \RedirectingA{G}{\loc}{\scont}\\[2mm]
  \end{array}
\]

\item Otherwise, the last initializer is a super initializer, $li = Super(G, \exprs)$:
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\FieldsA{\env}{li::[]}{\loc}{\scont}}{\val{s}}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\
	&&\textrm{with }\deref{\deref{\loc[f_i]}} = \val_{i}, \forall f_i \in Fs, \forall \val_i \in \val{s}\\
	\textrm{where:}\\
	\acont = \SuperA{G}{\loc}{\scont}\\[2mm]
  \end{array}
\]
\end{itemize}
The transitions for the initializer continuation are described below.\\[2mm]
\noindent
Besides redirecting and super initializers, in Kernel we also have field and local initializers, both containing an expression to evaluate, denoted as $Initializer(\expr) : LocalI(\variablemeta, \expr) + FieldI(f, \expr)$.\\[2mm]
Local initializers are special initializers in Kernel and they extend the environment for the execution of the initializer list.
The transition steps for initializer continuation are as follows:
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\contconf{\InitK{Local(\variablemeta, \expr) :: []}{\loc}{\scont}}{\val}
	& \Rightarrow &
	\scontconf{\scont}{\env'}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\env' = \ext{\env}{\variablemeta}{\val}\\[2mm]

	\contconf{\InitK{Local(\variablemeta, \expr) :: li :: []}{\loc}{\scont}}{\val}
	& \Rightarrow &
	\evallistconf{\exprs}{\env'}{\strace}{\cstrace}{\cex}{\acont}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\env' = \ext{\env}{\variablemeta}{\val}\\
	\hspace{5mm}\textrm{if } li = Super(G, \exprs):\\
	\hspace{8mm}\acont = \SuperA{G}{\loc}{\scont}\\
	\hspace{5mm}\textrm{if } li = Redirecting(G, \exprs):\\
	\hspace{8mm}\acont = \RedirectingA{G}{\loc}{\scont}\\[2mm]

	\contconf{\InitK{Local(\variablemeta, \expri{0}) :: Izs}{\loc}{\scont}}{\val}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env'}{st}{cex}{cst}{\econt'}\\[2mm]
	\textrm{where:}\\
	\hspace{5mm}\env' = \ext{\env}{\variablemeta}{\val}\\
	\hspace{5mm}Izs = Initializer(\expri{1}) :: Izs'\\
	\hspace{5mm}\econt' = \InitK{Izs}{\loc}{\env'}
  \end{array}
\]
\noindent
Note that when a local initializer is last in the initializer list, the environment resulted after the transition is discarded.
However, the corresponding expression has to be executed, because of side effects.
\\[2mm]
\noindent
Field initializers further initialize fields of the fresh instance.
Let $Field(f, \expr)$ be a field initializer.
Then the value stored at location $\loc' = (\deref{\loc})[f]$ in the store $S$ will be modified, where $\loc$ is the location of the previously allocated fresh instance for the object currently being initialized.

\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\contconf{\InitK{Field(f, \expr) :: []}{\loc}{\scont}}{\val}
	& \Rightarrow &
	\scontconf{\scont}{\env'}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\update{(\deref{\loc})[f]}{\val}\\[2mm]

	\contconf{\InitK{Field(f, \expr) :: li :: []}{\loc}{\scont}}{\val}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\update{(\deref{\loc})[f]}{\val}\\
	\hspace{5mm}\textrm{if } li = Super(G, \exprs):\\
	\hspace{8mm}\acont = \SuperA{G}{\loc}{\scont}\\
	\hspace{5mm}\textrm{if } li = Redirecting(G, \exprs):\\
	\hspace{8mm}\acont = \RedirectingA{G}{\loc}{\scont}\\[2mm]

	\contconf{\InitK{Field(f, \expri{0}) :: Izs}{\loc}{\scont}}{\val}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{st}{cex}{cst}{\econt}\\[2mm]
	\textrm{where:}\\
	\hspace{5mm}\update{(\deref\loc)[f]}{\val}\\
	\hspace{5mm}Izs = Initializer(\expri{1}) :: Izs'\\
	\hspace{5mm}\econt' = \InitK{Izs}{\loc}{\env}
  \end{array}
\]

\subsection{Yield}



\end{document}

% vim: tw=0
