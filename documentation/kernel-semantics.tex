\documentclass{article}

\usepackage{amsmath}
%
\usepackage{a4wide}
%
\usepackage{euler}
%
\usepackage{url,cite,amssymb,stmaryrd,alltt,xypic,appendix}
%
\usepackage{color,alltt}

\definecolor{shade}{gray}{0.75}

\newcommand{\shadethis}[1]{\colorbox{shade}
{\protect\rule[-0.95mm]{0mm}{3.95mm}\hspace{0.3mm}#1\hspace{0.3mm}}}

% Macros used below have been contributed in part by Olivier Danvy and Kevin Millikin
\input{danvy-millikin-LMCS.mac}

\begin{document}
\title{Dart Kernel Semantics \\ (draft)}

\maketitle

The small-step operational semantics of Dart Kernel is given by an abstract machine in the style of the CESK machine. The machine is defined by a single step transition function where each step of the machine starts in a configuration and deterministically gives a next configuration.

\section{Definitions}
\label{sec:definitions}
\subsection{Conventions}
\label{subsec:conventions}
\begin{itemize}
\setlength{\itemsep}{0pt}
\item Symbols ":" and $\in$ are used interchangeably.
\item Names of variables are italicized.
\item Names of variables of syntactic domains start with an upper case letter.
\item Names of domains are written in bold (e.g. $\dexpr$).
\item Names of configuration and continuation kinds are written in normal text (e.g. VarSetK).
\item Names of meta-functions start with lower case letter (e.g. extend).
\item Symbol ":=" is read as "denotes".
\item "$\mlist{\mathbf{X}}$" := domain of meta-lists of elements from domain "$\mathbf{X}$". Note that the word "List" here is not in bold, so that it isn't confused with the domain $\mathbf{List}$ of Dart objects.
\end{itemize}
\subsection{Domains}
\label{subsec:domains}
\[
  \begin{array}{ccll}
	\expr, \expri{i} & : & \dexpr & \textrm{syntactic domain of expressions}\\
	\exprs & : & \mlist{\dexpr}\\[2mm]

	\stmt, \stmti{i} & : & \dstmt & \textrm{syntactic domain of statements}\\
	\stmts & : & \mlist{\dstmt}  & \textrm{}\\[2mm]

	\econt & : & \decont & \textrm{domain of expression continuations}\\
	\acont & : & \dacont & \textrm{domain of application continuations}\\
	\scont & : & \dscont & \textrm{domain of statement continuations}\\
	\bcont & : & \dbcont & \textrm{domain of break continuations}\\
	\switchcont & : & \dswitchcont & \textrm{domain of switch continuations}\\[2mm]

	\lbl & : & \dlbl & \textrm{domain of labels}\\
	\lbl & : & \mlist{\dlbl} \\
	\clbl & : & \dclbl & \textrm{domain of switch labels}\\
	\clbl & : & \mlist{\dclbl} \\[2mm]

	\handler & : & \dhandler & \textrm{syntactic domain of exception handlers} \\
	\strace & : & \mlist{\dexpr} & \textrm{domain of stack traces}\\
	\cex & : &  \emptyset + \dval & \textrm{domain of current expetion values}\\
	\cstrace & : & \emptyset + \mlist{\dexpr} & \textrm{domain of current exception stack traces}\\[2mm]

	\varmeta & : & \dvardecl & \textrm{domain of variable declarations}\\
	\loc & : & \dlocation & \textrm{domain of store locations}\\
	\val & : & \dval & \textrm{domain of values}\\
	\vals & : & \mlist{\dval}\\
	\env & : & \denv & \textrm{domain of environments}\\[2mm]
  \end{array}
\]

\[
  \begin{array}{ccll}
	\formal, \formali{i} & : & \dvardecl\\
	\formals & : & \dformals = \mlist{\dvardecl} &\textrm{ domain of formals}\\

  \end{array}
\]
\subsection{Meta-functions}
\label{subsec:meta-functions}
\subsubsection{Dereferencing}
\label{subsubsection:dereferecing}
Function "$\deref{}$" is used to "dereference" items stored in environments. It has an implicit argument which is the store of CESK machine.

\begin{align*}
  \deref : \dlocation &\rightarrow \dval \\
  \deref\loc &=  \val, \textrm{ with $\val$ the value in store at location } \loc
\end{align*}

\subsubsection{String Concatenation}
\label{subsubsec:string-concatenation}
Function $stringValue$ concatenates strings from the given meta-list.

\[stringValue : \mlist{\dstring} \rightarrow \dstring\]

\subsubsection{Update}
\label{subsubsec:store-update}
\newcommand{\update}[2]{{#1} := {#2}}
Function "$\update{\loc}{\synval}$" updates the store at location $\loc \in \dlocation$ with value $\synval \in \dval$.

\subsubsection{Extend Environment}
\label{subsubsec:extend-env}

Function "$extend$" creates a new environment by extending the provided environment with new bindings for the variable declarations to fresh labels for each of the provided values.
% Exact definition on how the store is modified to be added
\[extend : \denv \times \mlist{\dvardecl} \times \mlist{\dval} \rightarrow  \denv \]



\subsection{Notations}
\label{subsec:notations}

\[
  \begin{array}{lcl}
    [] &:=& \textrm{empty list}\\
    X :: list &:=& \textrm{a meta-list that is constructed by adding element X to the head}\\
    && \textrm{of the meta-list list}
  \end{array}
\]
\subsection{Configurations for the CESK machine}
\label{subsec:cesk-configs}
The state space of the CESK machine contains various kinds of configurations, each containing components for applying the appropriate continuation in order to transition to the next configuration. 

\[
  \begin{array}{lcl}
	\evalconf{\expr}{\env}{st}{cex}{cst}{\econt} & : &
	\textrm{EvalConfiguration}\\

	\evallistconf{\exprs}{\env}{st}{cex}{cst}{\acont} & : &
	\textrm{EvalListConfiguration}\\

	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}  & : &
	\textrm{ExecConfiguration}\\[3mm]

	\contconf{\econt}{\val} & : &
	\textrm{ValuePassingConfiguration}\\

	\acontconf{\acont}{\vals} & : &
	\textrm{ApplicationConfiguration}\\

	\scontconf{\scont}{\env} & : &
	\textrm{ForwardConfiguration}\\[3mm]

	\throwconf{\handler}{\val}{\strace} & : &
	\textrm{ThrowConfiguration}\\

	\breakconf{\bcont} & : &
	\textrm{BreakConfiguration}\\

	\switchconf{\switchcont} & : &
	\textrm{SwitchConfiguration}\\

  \end{array}
\]
\subsection{Environment}
\label{subsec:env-definition}
The environment is a function that maps a variable to a location in the store.
\[\env \in \denv = \dvardecl \rightarrow \dlocation\] 
\subsection{Store}
\label{subsec:store-definition}
The store, $s$, maps a location, $\loc$, to a value, $\val$. The store is mutable and should not be confused with a function. It is possible to change the transition rules, so that the store is immutable, and right hand side configurations receive an updated copy of it. However, for the sake of simplicity, a global mutable store is assumed. 
\[s : \dlocation \rightarrow \dval \]
Therefore a variable look-up will consist of looking up the address of a variable from the environment with $\loc = \env(\varmeta)$ and reading the stored value $v$ with $\deref\loc$. For definition of "$\deref$" see Section~\ref{subsubsection:dereferecing} 

\subsection{Continuations}
\label{subsec:continuations-definition}

Continuation is the function that represents the rest of the program and is has the information needed to resume the execution of the program. 
There are various types of continuations depending on the next statement to be executed or next expression to be evaluated.

\subsection{Values}
\label{subsec:values}
\subsection{Literal values}
\label{subsubsec:literal-values}
\[
  \begin{array}{lcl}
	\val \in \dlitval &=& \mathbf{int} + \mathbf{bool} + \mathbf{double}\\
	&& + \mathbf{List} + \mathbf{Map} + \mathbf{String} + \mathbf{Symbol} + \mathbf{Type}
  \end{array}
\]
\subsection{Object values}
\label{subsec:object-values}
\[
  \begin{array}{lcl}
	\dobjval &:& \dclass \times \mlist{\dlocation}\\
	\dclass &:& superclass \times interfaces \times fields \times getters \times setters \times methods
  \end{array}
\]
\subsection{Function values}
\label{subsec:function-values}
\[
	\dfunval : \dformals \times \dstmt \times \denv
\]

\section{Abstract Syntax}
\label{sec:abstract-syntax}

\subsubsection{Expressions}
\label{sec:expr-syntax}

% Metavariables
\newcommand{\expressionmeta}{\ensuremath{\mathit{E}}}
\newcommand{\variablemeta}{\ensuremath{\mathit{X}}}
\newcommand{\boolmeta}{\ensuremath{\mathit{B}}}
\newcommand{\integermeta}{\ensuremath{\mathit{I}}}
\newcommand{\doublemeta}{\ensuremath{\mathit{D}}}
\newcommand{\stringmeta}{\ensuremath{\mathit{S}}}
\newcommand{\idmeta}{\ensuremath{\mathit{X}}}
\newcommand{\membermeta}{\ensuremath{\mathit{M}}}
\newcommand{\typemeta}{\ensuremath{\mathit{T}}}

% Syntax
\newcommand{\VariableGet}[1]{#1}
\newcommand{\VariableSet}[2]{#1=#2}

% TODO(kmillikin): Names should not ignore the library.
\newcommand{\PropertyGet}[2]{#1.#2}
\newcommand{\PropertySet}[3]{#1.#2=#3}

\newcommand{\DirectPropertyGet}[2]{#1.\{#2\}}
\newcommand{\DirectPropertySet}[3]{#1.\{#2\}=#3}

\newcommand{\SuperPropertyGet}[1]{\tt{super}.#1}
\newcommand{\SuperPropertySet}[2]{\tt{super}.#1=#2}

\newcommand{\StaticGet}[1]{#1}
\newcommand{\StaticSet}[2]{#1=#2}

%% MethodInvocation
%% DirectMethodInvocation
%% SuperMethodInvocation
%% StaticInvocation
%% ConstructorInvocation

\newcommand{\Not}[1]{!#1}
\newcommand{\AndExpression}[2]{#1\,\&\&\,#2}
\newcommand{\OrExpression}[2]{#1\,||\,#2}
\newcommand{\ConditionalExpression}[3]{#1\,?\,#2\,:\,#3}

%% StringConcatenation

\newcommand{\IsExpression}[2]{#1\,\tt{is}\,#2}
\newcommand{\AsExpression}[2]{#1\,\tt{as}\,#2}

%% SymbolLiteral
%% TypeLiteral

\newcommand{\ThisExpression}{\tt{this}}
\newcommand{\Rethrow}{\tt{rethrow}}
\newcommand{\Throw}[1]{\tt{throw}\,#1}

%% ListLiteral
%% MapLiteral

\newcommand{\AwaitExpression}[1]{\tt{await\,#1}}

%% FunctionExpression

\newcommand{\StringLiteral}[1]{#1}
\newcommand{\IntLiteral}[1]{#1}
\newcommand{\DoubleLiteral}[1]{#1}
\newcommand{\BoolLiteral}[1]{#1}
\newcommand{\NullLiteral}{\tt{null}}
\newcommand{\Let}[3]{\tt{let}\,#1=#2\,\tt{in}\,#3}

%% LoadLibrary
%% CheckLibraryIsLoaded
%% VectorCreation
%% VectorGet
%% VectorSet
%% VectorCopy
%% ClosureCreation
%% TypeInstantiation

\[
\begin{array}{rl}
  \expressionmeta \in \mathit{Expression} ::=
  & \VariableGet{\variablemeta} \\
  & \VariableSet{\variablemeta}{\expressionmeta} \\
  & \PropertyGet{\expressionmeta}{\idmeta} \\
  & \PropertySet{\expressionmeta_0}{\idmeta}{\expressionmeta_1} \\
  & \DirectPropertyGet{\expressionmeta}{\membermeta} \\
  & \DirectPropertySet{\expressionmeta_0}{\membermeta}{\expressionmeta_1} \\
  & \SuperPropertyGet{\idmeta} \\
  & \SuperPropertySet{\idmeta}{\expressionmeta} \\
  & \StaticGet{\membermeta} \\
  & \StaticSet{\membermeta}{\expressionmeta} \\
  & \Not{\expressionmeta} \\
  & \AndExpression{\expressionmeta_0}{\expressionmeta_1} \\
  & \OrExpression{\expressionmeta_0}{\expressionmeta_1} \\
  & \ConditionalExpression{\expressionmeta_0}{\expressionmeta_1}{\expressionmeta_2} \\
  & \IsExpression{\expressionmeta}{\typemeta} \\
  & \AsExpression{\expressionmeta}{\typemeta} \\
  & \ThisExpression \\
  & \Rethrow \\
  & \Throw{\expressionmeta} \\
  & \AwaitExpression{\expressionmeta} \\
  & \StringLiteral{\stringmeta} \\
  & \IntLiteral{\integermeta} \\
  & \DoubleLiteral{\doublemeta} \\
  & \BoolLiteral{\tt{true}} \\
  & \BoolLiteral{\tt{false}} \\
  & \NullLiteral \\
  & \Let{\variablemeta}{\expressionmeta_0}{\expressionmeta_1} \\
\end{array}  
\]


\section{Semantics}
\label{sec:semantics}
\subsection{Expression evaluation}
\label{subsec:expr-evaluation}
\subsubsection{Basic literal evaluation}
\label{subsubsec:basic-literal-eval}
Kernel literals are evaluated to a value $\synval \in \dlitval$. Transitions of the CESK machine for basic literals are presented below:
\[
  \begin{array}{lcll}
	\evalconf{\IntLiteral{\integermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\synval},
	\hspace{2mm}\synval = \mathrm{IntLiteral(\integermeta)} \in \mathbf{int}\\[2mm]

	\evalconf{\DoubleLiteral{\doublemeta} }{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\synval},
	\hspace{2mm}\synval = \mathrm{DoubleLiteral(\doublemeta)} \in \mathbf{double}\\[2mm]

	\evalconf{\BoolLiteral{\tt{true}}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\synval},
	\hspace{2mm}\synval = \mathrm{BoolValue(\tt{true})} = \tt{true}\in \mathbf{bool}\\[2mm]

	\evalconf{\BoolLiteral{\tt{false}}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\synval},
	\hspace{2mm}\synval = \mathrm{BoolValue(\tt{false})} = \tt{false}\in \mathbf{bool}\\[2mm]

	\evalconf{\StringLiteral{\stringmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\synval},
	\hspace{2mm}\synval = \mathrm{StringValue(\stringmeta)} \in \mathbf{String}

  \end{array}
\]

\subsubsection{Variable assignment and lookup}
\label{subsubsec:variable-assignment-and-lookup}
A variable $\varmeta$ are accessed by reading the value stored at location $\env(\varmeta)$ in the store $s$. Assigning a value to a variable will modify the store and the value stored at location  $\env(\varmeta)$.

\[
  \begin{array}{lcl}
	\evalconf{\varmeta}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\deref\env(\varmeta)}\\[2mm]

	\evalconf{\varmeta = \expr}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\varsetk{\env}{\varmeta}{\econt}}\\[2mm]

	\contconf{\varsetk{\env}{\varmeta}{\econt}}{\synval}
	& \Rightarrow &
	\contconf{\econt}{\synval}, \hspace{5mm} \deref\env(\varmeta) = \synval \textrm{ after transition}

  \end{array}
\]

\subsubsection{Boolean expressions}
% exact notation TBD
\newcommand{\true}{\tt{true}}
\newcommand{\false}{\tt{false}}

\[
  \begin{array}{lll}
	\evalconf{\neg\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\notk{\econt}}\\[2mm]

	\contconf{\notk{\econt}}{\true}
	& \Rightarrow &
	\contconf{\econt}{\false}\\[2mm]

	\contconf{\notk{\econt}}{\false}
	& \Rightarrow &
	\contconf{\econt}{\true}
  \end{array}
\]

\noindent
Let $\econt' = \andk{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}$ below:

\[
  \begin{array}{lcl}
	\evalconf{\expri{1} \land \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\andk{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\true}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

	\contconf{\andk{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\false}
	& \Rightarrow &
	\contconf{\econt}{\false}\\
  \end{array}
\]

\noindent
Let $\econt' = \ork{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}$ below:

\[
  \begin{array}{lcl}
	\evalconf{\expri{1} \lor \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\ork{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\false}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

	\contconf{\ork{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}}{\true}
	& \Rightarrow &
	\contconf{\econt}{\true}\\
  \end{array}
\]
\noindent
Let $\econt' = \conditionalk{\expri{1}}{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}$ below:
\[
  \begin{array}{lcl}
	\evalconf{\expr \textbf{ ? } \expri{1} \textbf{ : } \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\econt'}{\true}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]

	\contconf{\econt'}{\false}
	& \Rightarrow &
	\evalconf{\expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]
  \end{array}
\]

\subsubsection{Let}
Let $\econt' = \letk{\expri{2}}{\env}{\varmeta}{\strace}{\cstrace}{\cex}{\econt}$ below:
\[
  \begin{array}{lcl}
	\evalconf{\textbf{let } \varmeta = \expri{1} \textbf{ in } \expri{2}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\econt'}{\synval}
	& \Rightarrow &
	\evalconf{\expri{2}}{\env'}{\strace}{\cstrace}{\cex}{\econt}\\
	&&\env'=\ext{\env}{\varmeta}{\synval}\\[2mm]

  \end{array}
\]
\subsubsection{Static Invocation}
\[
  \begin{array}{lcl}
	\evalconf{\textbf{f }(\exprs)}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont'}\\
  \end{array}
\]
with:
\[
  \begin{array}{@{}c}
	\textbf{f} = \mathrm{FunctionNode}(\formals, \stmt_{body}),\\[2mm]
	\acont' = \staticinvocapp{\formals}{\stmt_{body}}{\textbf{f }(\exprs)::\strace}{\cstrace}{\cex}{\econt}
  \end{array}
\]

\subsubsection{Evaluation of list of expressions}
\[
  \begin{array}{lcl}
	\evallistconf{\expr :: \exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\evallistconf{[]}{\env}{\strace}{\cstrace}{\cex}{\acont}
	& \Rightarrow &
	\acontconf{\acont}{[]}
  \end{array}
\]
with:
\[
  \begin{array}{@{}c}
	\econt' = \exprlistk{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}
  \end{array}
\]
Expression list continuation application:
\[
  \begin{array}{lcl}
	\contconf{\exprlistk{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}}{\synval}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\valueapp{\synval}{\acont}}\\[2mm]

	\acontconf{\valueapp{\synval}{\acont}}{\synval s}
	& \Rightarrow &
	\acontconf{\acont}{\synval :: \synval s}

  \end{array}
\]


\subsubsection{Property extraction}
\label{subsubsec:property-extraction}
Kernel allows access of a member as a property, which can be either getter access, which executes the getter, or method extraction, which converts a method into a closure, also known as tear-off.
%% PropertyGetK
\newcommand{\propertygetk}{\mathrm{PropertyGetK}(\idmeta,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}

\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\evalconf{\PropertyGet{\expressionmeta}{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \propertygetk\\[2mm]
  \end{array}
\]

\noindent
After the evaluation of the receiver expression to a value $\val$, the property $\idmeta$ is looked up in methods, getters and implicit getters for the value $\val$. Let R be the result of such lookup.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\textrm{if R is a method with body }\stmt\textrm{ and formals }\formals :\\
	\hspace{2mm}\contconf{\propertygetk}{\synval}
	& \Rightarrow &
	\contconf{\econt}{\funval{\formals}{\stmt}{\env}}\\
	\textrm{where:}\\
	\hspace{5mm}\env = \ext{\env_{empty}}{\mathbf{this}}{\synval}\\[2mm]

	\textrm{if R is getter with statement body }\stmt :\\
	\hspace{2mm}\contconf{\propertygetk}{\synval}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
	\textrm{where:}\\
	\hspace{5mm}\env = \ext{\env_{empty}}{\mathbf{this}}{\synval}\\
	\hspace{5mm}\scont = \emptyset\\[2mm]

	\textrm{if R is an implicit getter for field }\idmeta :\\
	\hspace{2mm}\contconf{\propertygetk}{\synval}
	& \Rightarrow &
	\contconf{\econt}{\textrm{R}(\synval)}\\
  \end{array}
\]
%If the lookup fails, noSuchMethod is created/invoked accordingly (TBD)

\subsubsection{Direct property extraction}
\label{subsubsec:direct-property-extraction}
In Kernel a property can be accessed without lookup, by direct reference to the $AST$ node of said property. This implies that the lookup step above is bypassed.
%% DirectPropertyGetK
\newcommand{\dpropertygetk}{\mathrm{DPropertyGetK}(\membermeta,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\evalconf{\DirectPropertyGet{\expressionmeta}{\membermeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \dpropertygetk\\[2mm]

	\textrm{if }\membermeta \textrm{ is a method with body }\stmt\textrm{ and formals }\formals :\\
	\hspace{2mm}\contconf{\dpropertygetk}{\synval}
	& \Rightarrow &
	\contconf{\econt}{\funval{\formals}{\stmt}{\env}}\\
	\textrm{where:}\\
	\hspace{5mm}\env = \ext{\env_{empty}}{\mathbf{this}}{\synval}\\[2mm]

	\textrm{if }\membermeta \textrm{ is getter with statement body }\stmt :\\
	\hspace{2mm}\contconf{\dpropertygetk}{\synval}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
	\textrm{where:}\\
	\hspace{5mm}\env = \ext{\env_{empty}}{\mathbf{this}}{\synval}\\
	\hspace{5mm}\scont = \emptyset\\[2mm]

	\textrm{if }\membermeta \textrm{ is a field } :\\
	\hspace{2mm}\contconf{\dpropertygetk}{\synval}
	& \Rightarrow &
	\contconf{\econt}{\deref(\synval[\membermeta])}\\
  \end{array}
\]
\subsubsection{Property assignment}
\label{subsubsec:property-assignment}
% \newcommand{\PropertySet}[3]{#1.#2=#3}
An assignment changes the value stored at the location of the provided property name.
A property assignment in Kernel can be done by executing a setter or accessing an instance variable and setting its value.
\newcommand{\propertysetk}{\mathrm{PropertySetK}(\idmeta,\,\expressionmeta_1,\,\env,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}

\newcommand{\propertysetvk}{\mathrm{PropertySetValueK}(\synval_0,\,\idmeta,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}

\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\evalconf{\PropertySet{\expressionmeta_0}{\idmeta}{\expressionmeta_1}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expressionmeta_0}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \propertysetk\\[2mm]

	\contconf{\propertysetk}{\synval_0}
	& \Rightarrow &
	\evalconf{\expressionmeta_1}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \propertysetvk\\[2mm]
  \end{array}
\]

\noindent
After the evaluation of the receiver expression to a value $\synval_0$ and the argument to value $\synval_1$, the property $\idmeta$ is looked up in setters and implicit setters for the value $\synval_0$. Let R be the result of such lookup.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\textrm{if R is setter with statement body }\stmt \textrm{ and formal }\formal :\\
	\hspace{2mm}\contconf{\propertysetvk}{\synval_1}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
	\textrm{where:}\\
	\hspace{5mm}\env = \ext{\env_{empty}}{\mathbf{this} :: \formal :: []}{\synval_0 :: \synval_1 :: []}\\
	\hspace{5mm}\scont = \emptyset\\[2mm]

	\textrm{if R is an implicit setter for field }\idmeta :\\
	\hspace{2mm}\contconf{\propertygetk}{\synval}
	& \Rightarrow &
	\contconf{\econt}{\textrm{R}(\synval_0, \synval_1)}\\
  \end{array}
\]

\subsubsection{Direct property assignment}
\label{subsubsec:direct-property-assignment}
In Kernel a property can be set without lookup, by direct reference to the $AST$ node of said property. This implies that the lookup step above is bypassed.
%% DirectPropertyGetK
\newcommand{\dpropertysetk}{\mathrm{DPropertySetK}(\membermeta,\,\expressionmeta_1,\,\env,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}

\newcommand{\dpropertysetvk}{\mathrm{DPropertySetValueK}(\synval_0,\,\membermeta,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\evalconf{\DirectPropertySet{\expressionmeta_0}{\membermeta}{\expressionmeta_1}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \dpropertysetk\\[2mm]

	\contconf{\dpropertysetk}{\synval_0}
	& \Rightarrow &
	\evalconf{\expressionmeta_1}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \dpropertysetvk\\[2mm]

	\textrm{if }\membermeta \textrm{ is setter with statement body }\stmt \textrm{ and formal }\formal :\\
	\hspace{2mm}\contconf{\dpropertysetvk}{\synval_1}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
	\textrm{where:}\\
	\hspace{5mm}\env = \ext{\env_{empty}}{\mathbf{this} :: \formal :: []}{\synval_0 :: \synval_1 :: []}\\
	\hspace{5mm}\scont = \emptyset\\[2mm]

	\textrm{if }\membermeta \textrm{ is a field } :\\
	\hspace{2mm}\contconf{\dpropertysetvk}{\synval_1}
	& \Rightarrow &
	\contconf{\econt}{\update{\synval_0[\membermeta]}{\synval_1}}\\
  \end{array}
\]

\subsubsection{Super property get}
\label{subsubsec:super-property-get}
%\newcommand{\SuperPropertyGet}[1]{\tt{super}.#1}
Kernel allows access of a superclass member as a property, which can be either getter access, which executes the getter, or method extraction, which converts a method into a closure, also known as tear-off.
\newcommand{\this}{\tt{this}}
\newcommand{\superclass}[1]{superclass({#1})}

\noindent
Accessing a superclass member is accessed with the expression $\SuperPropertyGet{\idmeta}$ evaluated with the corresponding components: $\env$, $\strace$, $\handler$, $\cstrace$, $\cex$, $\econt$. Let $\val = \deref(\env(\this))$, $C = \superclass{\val}$ and $M$ the result of looking up $\idmeta$ in $C$.
\[
  \begin{array}{l@{\hspace{50mm}}}
	\textrm{If }\membermeta \textrm{ is a member method with body }\stmt \textrm{ and formals }\formals:\\
	\hspace{3mm}\evalconf{\SuperPropertyGet{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	\Rightarrow
	\contconf{\econt}{\funval{\formals}{\stmt}{\env'}}\\
	\hspace{5mm}\textrm{with }\env' = \ext{\env_{empty}}{\this}{\deref(\env(\this))}\\[2mm]

	\textrm{If }\membermeta \textrm{ is a getter method with body }\stmt :\\
	\hspace{3mm}\evalconf{\SuperPropertyGet{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	\Rightarrow
	\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
	\hspace{5mm}\textrm{with }\env' =  \ext{\env_{empty}}{\this}{\deref(\env(\this))}, \hspace{2mm}\scont = \emptyset\\[2mm]

	\textrm{If }\membermeta \textrm{ is a implicit field getter} :\\
	\hspace{3mm}\evalconf{\SuperPropertyGet{\idmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	\Rightarrow
	\contconf{\econt}{M(\deref(\env(\this)))}\\
  \end{array}
\]
\subsubsection{Super property set}
\label{subsubsec:super-property-set}
%\newcommand{\SuperPropertySet}[2]{\tt{super}.#1=#2}
\newcommand{\superpropertysetk}{\mathrm{SuperPropertySetK}(\idmeta,\,\env,\,\strace,\,\handler,\,\cstrace,\,\cex,\,\econt)}
Kernel supports assignment of a super member with the expression $\SuperPropertySet{\idmeta}{\expressionmeta}$. The transition is defined as follows:
\[
  \begin{array}{l@{\hspace{30mm}}}
	\evalconf{\SuperPropertySet{\idmeta}{\expressionmeta}}{\env}{\strace}{\cstrace}{\cex}{\econt}
	\Rightarrow
	\evalconf{\expressionmeta}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
	\textrm{with }\econt' = \superpropertysetk
  \end{array}
\]

Let $\val = \deref(\env(\this))$, $C = \superclass{\val}$ and $M$ the result of looking up $\idmeta$ in $C$.

\[
  \begin{array}{l@{\hspace{50mm}}}
	\textrm{If }\membermeta \textrm{ is a setter method with body }\stmt\textrm{ and formal }\formal:\\
	\hspace{3mm}\contconf{\superpropertysetk}{\synval}
	\Rightarrow
	\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
	\hspace{5mm}\textrm{with }\env' =  \ext{\env_{empty}}{\this :: \formal :: []}{\deref(\env(\this)) :: \synval :: []}, \hspace{2mm}\scont = \emptyset\\[2mm]

	\textrm{If }\membermeta \textrm{ is a implicit field setter} :\\
	\hspace{3mm}\contconf{\superpropertysetk}{\synval}
	\Rightarrow
	\contconf{\econt}{M(\deref(\env(\this)), \synval)}\\
  \end{array}
\]

\subsection{Statement execution}
\label{subsec:stmt-exectution}

\subsubsection{Variable Declaration}

Let $\econt' = \vardeclk{\env}{\varmeta}{\scont}$ below:
\[
  \begin{array}{lcl}
	\execconf{\textbf{var } \varmeta = \expr}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]

	\contconf{\econt'}{\synval}
	& \Rightarrow &
	\scontconf{\scont}{\ext{\env}{\varmeta}{\synval}}

  \end{array}
\]
\subsubsection{Block statements}

\[
  \begin{array}{lcl}
	\execconf{\lbrace\rbrace}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]

	\execconf{\lbrace\expr\rbrace}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\exprk{\scont}{\env}}\\[2mm]

	\execconf{\stmt :: \stmts}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}\\[2mm]

	\scontconf{\blocksk{\stmt :: \stmts}{\env}}{\env'}
	& \Rightarrow &
	\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}\\[2mm]

	\scontconf{\blocksk{[]}{\env}}{ \_ }
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]

  \end{array}
\]

with $\scont' = \blocksk{\stmts}{\env}$.

\subsubsection{If statement}

Let $\econt' = \ifcondk{\stmti{1}}{\stmti{2}}$ below:

\[
  \begin{array}{lcl}
	\execconf{\textbf{if } \expr \textbf{ then } \stmti{1} \textbf{ else } \stmti{2} }{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]
  \end{array}
\]
\[
  \begin{array}{lcl}
	\contconf{\econt'}{\true} 
	& \Rightarrow &
	\execconf{\stmti{1}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\[2mm]

	\contconf{\econt'}{\false} 
	& \Rightarrow &
	\execconf{\stmti{2}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}\\
  \end{array}
\]

\subsubsection{Return statement}

\[
  \begin{array}{lcl}
	\execconf{\textbf{return } \expr}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt}\\[2mm]
	
	\execconf{\textbf{return}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\contconf{\econt}{\textbf{null}}
  \end{array}
\]

\subsubsection{Loops}
\[
  \begin{array}{lcl}
	\execconf{\textbf{while } (\expr) \stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\[2mm]
  \end{array}
\]
with $\econt', \scont' = \whilecondk$.
\[
  \begin{array}{lcl}
	\contconf{\econt'}{\false}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]

	\contconf{\econt'}{\true}
	& \Rightarrow &
	\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont'}\\[2mm]

	\scontconf{\scont'}{\_}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
  \end{array}
\]
Loops \textbf{do while}, \textbf{for in}, for can be desugared to while loops with transformations performed before interpreting the program.

\subsection{Labels}

Kernel supports labelling statements, \textbf{L: $\stmt_{L}$}, and breaking to L, \textbf{break L}, which completes the execution of the labelled statement and proceeds to executing the rest of the program.
To support breaking to a label, we add a labels component, $\lbls$, to statement configurations. $\lbls$ represents a list of pairs mapping a labelled statement, \textbf{L: $\stmt_L$}, to a break statement continuation, $\bcont$. Executing a labelled statement inserts a new break label, $\lbl$ in the list of labels $\lbls$.

\[
  \begin{array}{lcl}
	\execconf{\textbf{L: }\stmt_{L}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\execconf{\stmt_{L}}{\env}{\lbl :: \lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
  \end{array}
\]
with:
\[\lbl = \mathrm{Label}(L, \bcont), \bcont = \mathrm{Break}(\env, \scont)\]
\subsection{Switch}
Kernel supports dispatching control among a number of cases with \textbf{switch} statements, where the target expression $\expr$ is evaluated and matched against the different case clauses of the switch statement. 
 
In Kernel, case clauses can have multiple constant expressions and there is no implicit fall-through between cases. Kernel supports continuing to execution of a preceding case clause with continue statements where the target of the continue statement is a preceding case clause, e.g, continue C with C = case $\expri{1..i}$: $\stmt$. To support continue, we add an optional $\clbls$ list, similar to the label list, which is set in a switch statement and unset otherwise.

The execution of a switch statement proceeds as follows: 

\[
  \begin{array}{lcl}
	\execconf{\textbf{switch }(\expr) \scases }{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\econt'}\\
  \end{array}
\]
with $\econt' = \switchk{\scases}{\clbls}$

If there is a matching case clause, its statement is executed with a new statement continuation that will throw when reached. The new statement continuation is necessary because implicit fall-through is not supported and an explicit break of the flow is required (with either of \textbf{continue, break, return, throw}).

\[
  \begin{array}{lcl}
	\contconf{\switchk{\scase :: \scases}{\clbls}}{\synval}
	\Rightarrow \hspace{30mm}\\
	\hspace{20mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\exitssk}
  \end{array}
\]
with:
\[
	\scase = \textbf{case } \expri{1}, \dots, \expri{i} \textbf{ : } \stmt \textrm{ and } \scase \textrm{ is a matching \textbf{case} clause}
\]
A case clause is matching if is \textbf{default} or there is at least one of the constant expressions in the case clause identical to the target value of the switch.

\noindent
If a non-matching \textbf{case} clause, $\scase$, is the target of a continue statement, it installs a new continue label, in order to support execution of its statement with the appropriate configuration.

\[
  \begin{array}{lcl}
	\contconf{\switchk{\scase :: \scases}{\clbls}}{\synval}
	\Rightarrow \hspace{30mm}\\
	\hspace{20mm}\contconf{\switchk{\scases}{\clbl :: \clbls}}{\synval}
  \end{array}
\]
with:
\[
  \begin{array}{l}
	\clbl = \continuel{\scase}{\switchcont},\\
	\switchcont = \continuek
  \end{array}
\]
\noindent
Otherwise, the execution continues as follows:
\[
  \begin{array}{lcl}
    \contconf{\switchk{\scase :: \scases}{\clbls}}{\synval}
	\Rightarrow \hspace{30mm}\\
	\hspace{20mm}\contconf{\switchk{\scases}{\clbls}}{\synval}\\[2mm]

	\contconf{\switchk{[]}{\clbls}}{\synval}
	\Rightarrow
	\scontconf{\scont}{\env}
  \end{array}
\]

\subsection{Exceptions}

Kernel supports structured exception handling with \textbf{try/catch} and \textbf{try/finally} statements. Exceptions are thrown with \textbf{throw} and \textbf{rethrow} expressions. To support throwing exceptions, we add a handler, $\handler$, and a stacktrace, $\strace$, component to expression configurations (and correspondingly, to statement configurations). To support \textbf{rethrow}, we add an optional current error, $\cex$, and current stack trace, $\cstrace$, which are set when inside a catch block and unset otherwise.

\[
  \begin{array}{lcl}
	\evalconf{\textbf{throw } \expr}{\env}{\strace}{\cstrace}{\cex}{\econt}
	& \Rightarrow &
	\evalconf{\expr}{\env}{\strace}{\cstrace}{\cex}{\throwk{(\textbf{throw } \expr) :: \strace}{\handler}}\\[2mm]

	\evalconf{\textbf{rethrow}}{\env}{\strace}{inr(\synval)}{\strace'}{\econt}
	& \Rightarrow &
	\throwconf{\handler}{\synval}{\strace'}\\[2mm]

	\contconf{\throwk{\strace}{\handler}}{\synval}
	& \Rightarrow &
	\throwconf{\handler}{\synval}{\strace}\\[2mm]

  \end{array}
\]

\noindent
\textbf{try/catch} handlers contain a list of on-catch handlers, environment, break labels, continue switch labels, exception handler, stacktrace, return continuation, and statement continuation. The handlers are tried in order to see if they match against the type of the exception. If none match, the exception is rethrown.

\noindent
Let $\econt' = \catchk{(\textbf{on T catch (e, s) }\stmt) :: cs}$ be a catch continuation containing a non-empty list of on-catch handlers:
\[
  \begin{array}{lcll}
	\throwconf{\econt'}{\synval}{\strace'}
	& \Rightarrow &
	\execconf{\stmt}{\env'}{\lbls}{\clbls}{\handler}{inr(\synval)}{inr(\strace')}{\econt}{\scont}
	&\textrm{ if V is T}\\[1mm]

	&&\textrm{with } \env' = extend(\env, e :: s :: [], \synval :: \strace' :: [])\\[2mm]

	\throwconf{\econt'}{\synval}{\strace'}
	& \Rightarrow &
	\throwconf{\catchk{cs}}{\synval}{\strace'}	&\textrm{ otherwise}\\[2mm]
	&&\textrm{with } \env' = extend(\env, e :: s :: [], \synval :: \strace' :: [])
  \end{array}
\]
\noindent
When a catch handler with no on-catch handlers is reached, the exception is rethrown.
\[
  \begin{array}{lcll}
	\throwconf{\catchk{[]}}{\synval}{\strace'}
	& \Rightarrow &
	\throwconf{\handler}{\synval}{\strace'}\hspace{20mm}
  \end{array}
\]
\noindent
\textbf{try/finally} handlers contain a statement, environment, break labels, continue switch labels, exception handler, stacktrace, and return continuation. Note that they do not contain a statement continuation because when control falls off the end of the finally statement the exception is rethrown. The statement is unconditionally executed:

\[
  \begin{array}{lcl}
	\throwconf{\finallyk{\stmt}}{\synval}{\strace'}
	\Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{inl()}{inl()}{\econt}{\rethrowsk{\synval}{\strace'}{\handler}}\hspace{20mm}\\[2mm]

	\scontconf{\rethrowsk{\synval}{\strace}{\handler}}{\_}
	\Rightarrow \throwconf{\handler}{\synval}{\strace}

  \end{array}
\]
\noindent
\textbf{try/catch} statements execute their body with a new handler:

\[
  \begin{array}{lcl}
	\execconf{\mathrm{TryCatch}(\stmt, cs)}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}
	\Rightarrow\\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler'}{\cex}{\cstrace}{\econt}
	{\scont}\hspace{50mm}
  \end{array}
\]
where $\handler' = \catchk{cs}$.


\noindent
\textbf{try/finally} statements execute their body with a new handler and additionally install new break and continue switch labels, a new return continuation, and a new statement continuation:

\[
  \begin{array}{lcl}
	\execconf{\mathrm{TryFinally}(\stmti{0}, \stmti{1})}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}
	\Rightarrow\\
	\execconf{\stmti{0}}{\env}{\lbls'}{\clbls'}{\handler'}{\cex}{\cstrace}{\econt'}{\scont'}
	  \end{array}
\]
where:

\[
  \begin{array}{lcl}
	\handler' = \finallyk{\stmti{0}}\hspace{50mm}\\[2mm]

	\econt' = \finallyretk{\stmti{1}}\\[2mm]

	\scont' = \finallysk{\stmti{1}}\\[2mm]

	\lbls' = \lbrace \mathrm{Label}(L, \bcont') \mid \mathrm{Label}(L, \bcont) \in \lbls\rbrace \\
	\hspace{10mm}\textrm{where } \bcont = \finallybreak{\stmti{1}}{\bcont}\\[2mm]
	\clbls' =  \lbrace \continuel{C}{\switchcont'} \mid  \continuel{C}{\switchcont} \in \clbls\rbrace\\
	\hspace{10mm}\textrm{where } \switchcont' = \finallycontinue{\stmti{1}}{\switchcont}

  \end{array}
\]
\subsection{Break}
\textbf{break L} statements break from an enclosing label \textbf{L} and execute the break continuation corresponding to the label in the list of labels $\lbls$.

Let $\lbl = Label(L', \bcont) \in \lbls \textrm{ with } L' == \mathbf{L}$ below:
\[
  \begin{array}{lcl}
	\execconf{\textbf{break L}}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}
	& \Rightarrow &
	\breakconf{\bcont}\\[2mm]

	\breakconf{\mathrm{Break}(\env, \scont)}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]

	\breakconf{\finallybreak{\stmt}{\bcont}}
	& \Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\mathrm{BreakSK}(\bcont)}\\[2mm]

	\scontconf{\mathrm{BreakSK}(\bcont)}{\env}
	& \Rightarrow &
	\breakconf{\bcont}

  \end{array}
\]

\subsection{Continue}
\textbf{continue L} statements continue to executing the statement of a preceding case clause, labelled with \textbf{L} and execute the continue continuation corresponding to the label in the list of labels $\clbls$.

Let $\clbl = \continuel{L'}{\switchcont} \in \clbls \textrm{ with } L' == \mathbf{L}$ below:
\[
  \begin{array}{lcl}
	\execconf{\textbf{continue L}}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}
	& \Rightarrow \\
	\hspace{10mm}\switchconf{\switchcont}\\[2mm]

	\switchconf{\continuek}
	& \Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\scont}\\[2mm]

	\switchconf{\finallycontinue{\stmt}{\switchcont}}
	& \Rightarrow \\
	\hspace{10mm}\execconf{\stmt}{\env}{\lbls}{\clbls}{\handler}{\cex}{\cstrace}{\econt}{\mathrm{SwitchContinueSK}(\switchcont)}\\[2mm]

	\scontconf{\mathrm{SwitchContinueSK}(\switchcont)}{\env}
	& \Rightarrow \\
	\hspace{10mm}\switchconf{\switchcont}
  \end{array}
\]
\subsection{Closures}
\subsubsection{Function expressions}

Kernel supports encapsulating an executable unit of code with function expressions. To support function expressions we introduce $fv = \funval{\stmt_{body}}{\formals}{\env} \in \dfunval$ as a value that has the function statement body, $\stmt_{body} \in \dstmt$, its list of formal parameters, $\formals \in \dformals$, and the environment, $\env \in \denv$ in scope of the function expression. This ensures that there are no free variables in the body of $fv$. $fv \in \dfunval$ has only one method, $call$.

Let $F$ be a function expression with a body $\stmt_{body}$ and a list of formal parameters, $\formals$.

\[
  \begin{array}{lcl}
	\evalconf{F}{\env}{st}{cex}{cst}{\econt}
	& \Rightarrow &
	\contconf{\econt}{\funval{\formals}{\stmt_{body}}{\env}}
  \end{array}
\]
%<f, ρ, KE>exec → <KE, FValue(f, α)>cont  with  !α = ρ
\subsubsection{Function declaration}
Kernel supports local function declaration, where a final variable stores a function value. 
Let $F$ be a function with a body $\stmt_{body}$ and a list of formal parameters, $\formals$, and let $fun \in \dvardecl$ be the corresponding final variable declaration.
\[
  \begin{array}{lcl}
	\execconf{fun(\formals) \stmt_{body}}{\env}{\lbls}{\clbls}{\handler}{\cstrace}{\cex}{\econt}{\scont}
	& \Rightarrow &
	\contconf{\econt}{\funval{\stmt_{body}}{\formals}{\env'}}
  \end{array}
\]
where $\env' = \ext{\env}{fun}{\funval{\stmt_{body}}{\formals}{\env'}}$.

\subsection{New instance creation}

The expression \textbf{new} invokes a constructor to produce a new instance. The target constructor \textbf{Q} has a list of formal parameters, $\formals$, a list of initializers, $Izs$, and a statement body, $\stmt_{body}$. The invocation of a constructor \textbf{Q} with \textbf{new Q}($\exprs$) proceeds as follows:
\[
  \begin{array}{lcl}
	\evalconf{\textbf{new Q}(\exprs)}{\env}{st}{cex}{cst}{\econt}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{st}{cex}{cst}{\acont'}\\[2mm]
  \end{array}
\]
where $\acont' = \ctrapp{\textbf{Q}}{\econt}$.
\[
  \begin{array}{lcl}
	\acontconf{\ctrapp{\textbf{Q}}{\econt}}{\synval{s}}
	& \Rightarrow &
	\contconf{\initk{Q}{\env}{\scont}}{!\loc}
  \end{array}
\]
\noindent
where $\loc$ is the location of the newly allocated instance, $\val \in \dobjval$, in the store. The value $\val$ stores the class of the object and the fields, as a list of freshly allocated labels for each field of the new instance.
\[
  \begin{array}{l}
	\deref\loc = \objval \in \dobjval, fields \in \mlist{\dlocation}\\
	\env' = extend(\env_{empty}, \formals, \synval{s})\\
	\scont = \newsk{\econt}{\loc} \\[2mm]

	\scontconf{\newsk{\econt}{\loc}}{\env}
	\Rightarrow
	\contconf{\econt}{\deref\loc}
  \end{array}
\]

\noindent
Let $li = last(Izs)$ be the last initializer in the list of initializers, $Izs$, of constructor \textbf{Q}.

\noindent
When $li$ is a redirecting initializer to target constructor \textbf{G}, then execution of constructor \textbf{Q} proceeds immediately with execution of its initializer list, $Izs$.
\[
  \begin{array}{lcl}
	\contconf{\initk{Q}{\env}{\scont}}{\synval}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\	
	&&
	\textrm{if } Izs = RedirectingI(G, \exprs) :: []\\
	\textrm{where:}\\
	\acont = \redapp{G}{\loc}{\scont}\\
	\deref\loc = \synval
	\\[2mm]

	\contconf{\initk{Q}{\env}{\scont}}{\synval}
	& \Rightarrow &
	\evalconf{\expr}{\env}{st}{cex}{cst}{\econt'}\\
	&&
	\textrm{otherwise}\\
	\textrm{where:}\\

	fi = Initializer(\expr) \textrm{, first initializer in }Izs\\
	\econt' = \initializerk{Izs}{\loc}{\env}{\scont}\\
	\deref\loc = \synval\\[2mm]

	\acontconf{\redapp{G}{\loc}{\scont}}{\synval{s}}
	& \Rightarrow &
	\contconf{\initk{G}{\env'}{\scont}}{\deref\loc}\\[2mm]
	\textrm{where:}\\
	\env' = extend(\env_{empty}, \formals, \synval{s})
  \end{array}
\]
\noindent
Otherwise, \textbf{Q} is a non-redirecting generative constructor, and execution of \textbf{Q} proceeds with evaluation of field initializers in the immediately enclosing class.
\noindent
Let \textbf{Q} be a constructor with non empty initializer list, $Izs$ and a constructor body $\stmt_{body}$.
\[
  \begin{array}{lcl}
	\contconf{\initk{Q}{\env}{\scont}}{\synval}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\[2mm]

	\textrm{where:}\\
	\env' = \ext{\env}{\mathbf{this}}{\deref\loc}
	&&
	\exprs = \textrm{initializer expressions for instance fields}\\
	\deref\loc = \synval
	&&
	\acont = \fieldsapp{\env}{Izs}{\loc}{\scont'}\\
	&&
	\scont' = \bodysk{\stmt_{body}}{\env'}{\scont}
  \end{array}
\]
\noindent
To further initialize the new instance, the body of the constructor will be executed. In Kernel the body of a constructor is executed after the execution of the initializer list and its super constructor.
\noindent
To support this, we add a new statement continuation, $BodySK$, that has the constructor body statement, the environment, the error handlers and stacktraces, and the next statement continuation.
\[
  \begin{array}{lcl}
	\scontconf{\bodysk{\stmt}{\env}{\scont}}{\_}
	& \Rightarrow &
	\execconf{\stmt}{\env}{[]}{[]}{\handler}{\cex}{\cstrace}{\econt}{\scont}
  \end{array}
\]

\noindent
After the evaluation of the initializer expressions, the labels for each field in the object value are updated accordingly. An update of field $f_i$, stored at location $\loc' = (\deref\loc)[f_i]$ with value $\synval_i$ is expressed as $\update{(\deref\loc)[f_i]}{\synval_{i}}$, so the following holds $\deref\loc' = \deref\deref\loc[f_i] = \synval_{i}$ after the update.

\noindent
Let $Fs$ be the list of fields for value $\deref\loc$ for the class immediately enclosing the current constructor below.

If the initializer list is empty, $Izs = []$, the next statement continuation is executed.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\fieldsapp{\env}{Izs}{\loc}{\scont}}{\synval{s}}
	& \Rightarrow &
	\scontconf{\scont}{\env}\\[2mm]
	&&\textrm{with }\deref\deref\loc[f_i] = \synval_{i}, \forall f_i \in Fs, \forall \synval_i \in \synval{s}
  \end{array}
\]
\noindent
In Kernel, a super initializer or a redirecting initializer, when present, will appear last in the initializer list.\\
If the initializer list contains at least two initializers, $Izs = Ininitalizer(E) :: Izs', Izs' \neq []$, we can assume that the next initializer to execute is a local or a field initializer.
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\fieldsapp{\env}{Izs}{\loc}{\scont}}{\synval{s}}
	& \Rightarrow &
	\evalconf{\expr}{\env}{st}{cex}{cst}{\econt'}\\[2mm]
	&&\textrm{with }\deref\deref\loc[f_i] = \synval_{i}, \forall f_i \in Fs, \forall \synval_i \in \synval{s}\\
	\textrm{where:}\\
	\hspace{5mm}\econt' = \initk{Izs}{\loc}{\env}
  \end{array}
\]

\noindent
Otherwise, there is only one initializer to execute in the initializer list, $li$: \\
\begin{itemize}

\item When $li$ is field or local initializer, the transition is identical to the rule for non empty and non singleton initializer lists, described above.\\
\item When the last initializer is a redirecting constructor, i.e. $li = RedirectingI(G, \exprs)$, the transition is as follows:
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\fieldsapp{\env}{li::[]}{\loc}{\scont}}{\synval{s}}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\	
	&&\textrm{with }\deref\deref\loc[f_i] = \synval_{i}, \forall f_i \in Fs, \forall \synval_i \in \synval{s}\\
	\textrm{where:}\\
	\acont = \redapp{G}{\loc}{\scont}\\[2mm]
  \end{array}
\]

\item Otherwise, the last initializer is a super initializer, $li = Super(G, \exprs)$:
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\acontconf{\fieldsapp{\env}{li::[]}{\loc}{\scont}}{\synval{s}}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\	
	&&\textrm{with }\deref\deref\loc[f_i] = \synval_{i}, \forall f_i \in Fs, \forall \synval_i \in \synval{s}\\
	\textrm{where:}\\
	\acont = \superapp{G}{\loc}{\scont}\\[2mm]
  \end{array}
\]
\end{itemize}
The transitions for the initializer continuation are described below.\\[2mm]
\noindent
Besides redirecting and super initializers, in Kernel we also have field and local initializers, both containing an expression to evaluate, denoted as $Initializer(\expr) : LocalI(\variablemeta, \expr) + FieldI(f, \expr)$.\\[2mm]
Local initializers are special initializers in Kernel and they extend the environment for the execution of the initializer list. The transition steps for initializer continuation are as follows:
\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\contconf{\initk{Local(\variablemeta, \expr) :: []}{\loc}{\scont}}{\synval}
	& \Rightarrow &
	\scontconf{\scont}{\env'}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\env' = \ext{\env}{\variablemeta}{\synval}\\[2mm]

	\contconf{\initk{Local(\variablemeta, \expr) :: li :: []}{\loc}{\scont}}{\synval}
	& \Rightarrow &
	\evallistconf{\exprs}{\env'}{\strace}{\cstrace}{\cex}{\acont}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\env' = \ext{\env}{\variablemeta}{\synval}\\
	\hspace{5mm}\textrm{if } li = Super(G, \exprs):\\
	\hspace{8mm}\acont = \superapp{G}{\loc}{\scont}\\
	\hspace{5mm}\textrm{if } li = Redirecting(G, \exprs):\\
	\hspace{8mm}\acont = \redapp{G}{\loc}{\scont}\\[2mm]

	\contconf{\initk{Local(\variablemeta, \expri{0}) :: Izs}{\loc}{\scont}}{\synval}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env'}{st}{cex}{cst}{\econt'}\\[2mm]
	\textrm{where:}\\
	\hspace{5mm}\env' = \ext{\env}{\variablemeta}{\synval}\\
	\hspace{5mm}Izs = Initializer(\expri{1}) :: Izs'\\
	\hspace{5mm}\econt' = \initk{Izs}{\loc}{\env'}
  \end{array}
\]
\noindent
Note that when a local initializer is last in the initializer list, the environment resulted after the transition is discarded. However, the corresponding expression has to be executed, because of side effects.
\\[2mm]
\noindent
Field initializers further initialize fields of the fresh instance. Let $Field(f, \expr)$ be a field initializer. Then the value stored at location $\loc' = (\deref\loc)[f]$ in the store $S$ will be modified, where $\loc$ is the location of the previously allocated fresh instance for the object currently being initialized.

\[
  \begin{array}{lcl@{\hspace{30mm}}}
	\contconf{\initk{Field(f, \expr) :: []}{\loc}{\scont}}{\synval}
	& \Rightarrow &
	\scontconf{\scont}{\env'}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\update{(\deref\loc)[f]}{\synval}\\[2mm]

	\contconf{\initk{Field(f, \expr) :: li :: []}{\loc}{\scont}}{\synval}
	& \Rightarrow &
	\evallistconf{\exprs}{\env}{\strace}{\cstrace}{\cex}{\acont}\\[1mm]
	\textrm{where:}\\
	\hspace{5mm}\update{(\deref\loc)[f]}{\synval}\\
	\hspace{5mm}\textrm{if } li = Super(G, \exprs):\\
	\hspace{8mm}\acont = \superapp{G}{\loc}{\scont}\\
	\hspace{5mm}\textrm{if } li = Redirecting(G, \exprs):\\
	\hspace{8mm}\acont = \redapp{G}{\loc}{\scont}\\[2mm]

	\contconf{\initk{Field(f, \expri{0}) :: Izs}{\loc}{\scont}}{\synval}
	& \Rightarrow &
	\evalconf{\expri{1}}{\env}{st}{cex}{cst}{\econt}\\[2mm]
	\textrm{where:}\\
	\hspace{5mm}\update{(\deref\loc)[f]}{\synval}\\
	\hspace{5mm}Izs = Initializer(\expri{1}) :: Izs'\\
	\hspace{5mm}\econt' = \initk{Izs}{\loc}{\env}
  \end{array}
\]



\end{document}